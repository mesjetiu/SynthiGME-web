<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SynthiGME Audio Test Harness</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 2rem auto;
      padding: 1rem;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #00d9ff; }
    .status { 
      padding: 0.5rem 1rem; 
      border-radius: 4px; 
      margin: 0.5rem 0;
    }
    .ready { background: #0f5132; }
    .loading { background: #664d03; }
    .error { background: #842029; }
    #log {
      background: #0d0d0d;
      padding: 1rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
    .log-entry { margin: 0.25rem 0; }
    .log-entry.info { color: #6c757d; }
    .log-entry.success { color: #198754; }
    .log-entry.error { color: #dc3545; }
  </style>
</head>
<body>
  <h1>ğŸ›ï¸ SynthiGME Audio Test Harness</h1>
  
  <div id="status" class="status loading">Cargando worklets...</div>
  
  <div id="log"></div>

  <script type="module">
    /**
     * Audio Test Harness
     * 
     * Este archivo se carga en Playwright y expone funciones globales
     * para ejecutar tests de audio con Web Audio API real.
     * 
     * Los tests llaman a estas funciones via page.evaluate().
     */

    const log = (msg, type = 'info') => {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toISOString().slice(11, 23)}] ${msg}`;
      document.getElementById('log').appendChild(entry);
      console.log(`[AudioHarness] ${msg}`);
    };

    const setStatus = (msg, type) => {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = `status ${type}`;
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS DE ANÃLISIS ESPECTRAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Calcula el espectro de magnitud usando DFT simple (mÃ¡s lento pero confiable).
     * Solo calcula los bins necesarios para el anÃ¡lisis.
     */
    function computeSpectrum(samples, sampleRate) {
      const N = samples.length;
      const spectrum = [];
      
      // Solo calcular hasta Nyquist y con resoluciÃ³n razonable
      const maxBins = Math.min(N / 2, 2048);
      const binStep = Math.max(1, Math.floor(N / 2 / maxBins));
      
      for (let k = 1; k < maxBins; k++) {
        const binIndex = k * binStep;
        let re = 0;
        let im = 0;
        
        // DFT para este bin especÃ­fico
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * binIndex * n / N;
          re += samples[n] * Math.cos(angle);
          im += samples[n] * Math.sin(angle);
        }
        
        const magnitude = Math.sqrt(re * re + im * im) / N;
        const db = 20 * Math.log10(magnitude + 1e-10);
        const frequency = binIndex * sampleRate / N;
        
        spectrum.push({
          bin: binIndex,
          frequency,
          magnitude,
          db
        });
      }
      
      return spectrum;
    }

    /**
     * VersiÃ³n rÃ¡pida: usa zero-crossing para estimar frecuencia
     * y picos para anÃ¡lisis bÃ¡sico de armÃ³nicos.
     */
    function analyzeSignalFast(samples, sampleRate) {
      // Estimar frecuencia por zero crossings
      let crossings = 0;
      for (let i = 1; i < samples.length; i++) {
        if ((samples[i - 1] < 0 && samples[i] >= 0)) {
          crossings++;
        }
      }
      const duration = samples.length / sampleRate;
      const estimatedFreq = crossings / duration;
      
      // Calcular RMS y peak
      let sum = 0;
      let peak = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
        if (Math.abs(samples[i]) > peak) peak = Math.abs(samples[i]);
      }
      const rms = Math.sqrt(sum / samples.length);
      
      return {
        estimatedFreq,
        rms,
        peak
      };
    }

    /**
     * Encuentra la frecuencia dominante en el espectro.
     */
    function findDominantFrequency(spectrum, minDb = -80) {
      let maxMag = 0;
      let dominant = null;
      
      // Ignorar DC (bin 0) y frecuencias muy bajas
      for (let i = 1; i < spectrum.length; i++) {
        const bin = spectrum[i];
        if (bin.magnitude > maxMag && bin.frequency > 10) {
          maxMag = bin.magnitude;
          dominant = bin;
        }
      }
      
      return dominant;
    }

    /**
     * Encuentra armÃ³nicos de una frecuencia fundamental.
     */
    function findHarmonics(spectrum, fundamental, count = 5, tolerance = 5) {
      const harmonics = [];
      
      for (let n = 1; n <= count; n++) {
        const targetFreq = fundamental * n;
        let best = null;
        let bestDiff = Infinity;
        
        for (const bin of spectrum) {
          const diff = Math.abs(bin.frequency - targetFreq);
          if (diff < tolerance && diff < bestDiff) {
            bestDiff = diff;
            best = bin;
          }
        }
        
        harmonics.push({
          harmonic: n,
          expected: targetFreq,
          found: best
        });
      }
      
      return harmonics;
    }

    /**
     * Calcula la DistorsiÃ³n ArmÃ³nica Total (THD).
     */
    function measureTHD(spectrum, fundamental, numHarmonics = 5) {
      const harmonics = findHarmonics(spectrum, fundamental, numHarmonics + 1);
      
      const fundamentalMag = harmonics[0]?.found?.magnitude || 0;
      if (fundamentalMag === 0) return null;
      
      let harmonicPower = 0;
      for (let i = 1; i < harmonics.length; i++) {
        const mag = harmonics[i]?.found?.magnitude || 0;
        harmonicPower += mag * mag;
      }
      
      return Math.sqrt(harmonicPower) / fundamentalMag * 100; // Porcentaje
    }

    /**
     * Calcula RMS de una seÃ±al.
     */
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
      }
      return Math.sqrt(sum / samples.length);
    }

    /**
     * Calcula el pico de una seÃ±al.
     */
    function calculatePeak(samples) {
      let max = 0;
      for (let i = 0; i < samples.length; i++) {
        const abs = Math.abs(samples[i]);
        if (abs > max) max = abs;
      }
      return max;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FUNCIONES DE TEST EXPUESTAS GLOBALMENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Renderiza audio de un oscilador con OfflineAudioContext.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {string} config.waveform - Tipo de onda: 'sine'|'sawtooth'|'triangle'|'pulse'
     * @param {number} config.frequency - Frecuencia en Hz
     * @param {number} config.duration - DuraciÃ³n en segundos
     * @param {number} [config.pulseWidth=0.5] - Ancho de pulso (0.01-0.99)
     * @param {number} [config.symmetry=0.5] - SimetrÃ­a del sine (0-1)
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testSynthOscillator = async function(config) {
      const {
        waveform = 'sine',
        frequency = 440,
        duration = 0.5,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering ${waveform} @ ${frequency}Hz, duration=${duration}s`);

      // Crear OfflineAudioContext
      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      log('Worklet registrado');

      // Crear nodo de oscilador
      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform,
          sineShapeAttenuation: 0,  // Sin atenuaciÃ³n para tests de forma pura
          sinePurity: 1.0            // Seno puro en centro
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('gain').value = 1.0;

      // Conectar a destino
      oscillator.connect(offline.destination);

      // Renderizar
      log('Iniciando render...');
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;
      log(`Render completado en ${renderTime.toFixed(1)}ms`, 'success');

      // Obtener samples
      const samples = buffer.getChannelData(0);
      
      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const harmonics = findHarmonics(spectrum, frequency, 10);
      const thd = measureTHD(spectrum, frequency, 5);
      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      // Verificar forma de onda (primeros N samples para anÃ¡lisis de fase)
      const phaseAnalysis = {
        startValue: samples[0],
        quarterCycle: samples[Math.floor(sampleRate / frequency / 4)],
        halfCycle: samples[Math.floor(sampleRate / frequency / 2)],
        threeQuarterCycle: samples[Math.floor(sampleRate / frequency * 0.75)]
      };

      return {
        config,
        renderTime,
        sampleCount: samples.length,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        harmonics: harmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? {
            frequency: h.found.frequency,
            magnitude: h.found.magnitude,
            db: h.found.db
          } : null
        })),
        thd,
        rms,
        peak,
        phaseAnalysis,
        // Incluir algunos samples para verificaciÃ³n visual
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * Renderiza audio con mÃºltiples formas de onda simultÃ¡neas (modo multi).
     */
    window.testSynthOscillatorMulti = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sineLevel = 1,
        sawLevel = 0,
        triLevel = 0,
        pulseLevel = 0,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering multi-waveform @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 2,  // 2 canales: sine+saw, tri+pulse
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'multi',
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 2,
        outputChannelCount: [1, 1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('sineLevel').value = sineLevel;
      oscillator.parameters.get('sawLevel').value = sawLevel;
      oscillator.parameters.get('triLevel').value = triLevel;
      oscillator.parameters.get('pulseLevel').value = pulseLevel;

      // Crear merger para capturar ambos canales
      const merger = offline.createChannelMerger(2);
      oscillator.connect(merger, 0, 0);  // sine+saw â†’ canal 0
      oscillator.connect(merger, 1, 1);  // tri+pulse â†’ canal 1
      merger.connect(offline.destination);

      const buffer = await offline.startRendering();
      
      const channel0 = buffer.getChannelData(0);  // sine + saw
      const channel1 = buffer.getChannelData(1);  // tri + pulse

      return {
        config,
        channel0: {
          rms: calculateRMS(channel0),
          peak: calculatePeak(channel0),
          spectrum: computeSpectrum(channel0, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel0.slice(0, 256))
        },
        channel1: {
          rms: calculateRMS(channel1),
          peak: calculatePeak(channel1),
          spectrum: computeSpectrum(channel1, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel1.slice(0, 256))
        }
      };
    };

    /**
     * Renderiza audio a travÃ©s de una cadena de nodos (simula matriz).
     * Ãštil para tests de routing y ganancias.
     */
    window.testSignalRouting = async function(config) {
      const {
        sourceFrequency = 440,
        sourceWaveform = 'sine',
        gains = [1.0],  // Array de ganancias a aplicar en cadena
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Routing test: ${sourceWaveform}@${sourceFrequency}Hz through ${gains.length} gain stages`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador fuente
      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: sourceWaveform }
      });
      osc.parameters.get('frequency').value = sourceFrequency;
      osc.parameters.get('gain').value = 1.0;

      // Crear cadena de ganancias (simulando pines de matriz)
      let lastNode = osc;
      const gainNodes = [];
      
      for (const gainValue of gains) {
        const gainNode = offline.createGain();
        gainNode.gain.value = gainValue;
        lastNode.connect(gainNode);
        lastNode = gainNode;
        gainNodes.push({ requestedGain: gainValue, actualGain: gainNode.gain.value });
      }

      lastNode.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Calcular ganancia total esperada vs real
      const expectedTotalGain = gains.reduce((a, b) => a * b, 1.0);
      const actualPeak = calculatePeak(samples);

      return {
        config,
        gainNodes,
        expectedTotalGain,
        actualPeak,
        rms: calculateRMS(samples),
        spectrum: computeSpectrum(samples, sampleRate).slice(0, 200)  // MÃ¡s bins para mejor resoluciÃ³n
      };
    };

    /**
     * Test de latencia: mide el tiempo desde trigger hasta primer sample no-cero.
     */
    window.testLatency = async function(config) {
      const {
        frequency = 1000,
        sampleRate = 44100,
        duration = 0.1
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'pulse' }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Encontrar primer sample con seÃ±al significativa
      let firstNonZeroIndex = -1;
      const threshold = 0.001;
      for (let i = 0; i < samples.length; i++) {
        if (Math.abs(samples[i]) > threshold) {
          firstNonZeroIndex = i;
          break;
        }
      }

      const latencySamples = firstNonZeroIndex;
      const latencyMs = latencySamples >= 0 ? (latencySamples / sampleRate * 1000) : null;

      return {
        latencySamples,
        latencyMs,
        firstSamples: Array.from(samples.slice(0, 20))
      };
    };

    /**
     * Test de anti-aliasing: verifica que no hay frecuencias espurias sobre Nyquist.
     */
    window.testAntiAliasing = async function(config) {
      const {
        frequency = 10000,  // Alta frecuencia para provocar aliasing
        waveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Anti-aliasing test: ${waveform} @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);
      const spectrum = computeSpectrum(samples, sampleRate);

      // Encontrar frecuencias significativas (> -40dB)
      const significantFreqs = spectrum.filter(bin => bin.db > -40);
      
      // Calcular quÃ© armÃ³nicos deberÃ­an existir vs cuÃ¡les estÃ¡n aliasados
      const nyquist = sampleRate / 2;
      const expectedHarmonics = [];
      const aliasedHarmonics = [];
      
      for (let n = 1; n <= 20; n++) {
        const harmonicFreq = frequency * n;
        if (harmonicFreq < nyquist) {
          expectedHarmonics.push({ n, frequency: harmonicFreq });
        } else {
          // Frecuencia aliasada = |freq - N * sampleRate|
          const aliasedFreq = Math.abs(harmonicFreq - Math.round(harmonicFreq / sampleRate) * sampleRate);
          aliasedHarmonics.push({ n, original: harmonicFreq, aliased: aliasedFreq });
        }
      }

      // Verificar que no hay energÃ­a significativa en frecuencias aliasadas
      const aliasingDetected = [];
      for (const alias of aliasedHarmonics) {
        const found = spectrum.find(bin => 
          Math.abs(bin.frequency - alias.aliased) < 20 && bin.db > -50
        );
        if (found) {
          aliasingDetected.push({
            ...alias,
            detectedMagnitude: found.magnitude,
            detectedDb: found.db
          });
        }
      }

      return {
        config,
        nyquist,
        expectedHarmonics: expectedHarmonics.length,
        aliasedHarmonics: aliasedHarmonics.length,
        aliasingDetected,
        hasAliasing: aliasingDetected.length > 0,
        significantFreqs: significantFreqs.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        }))
      };
    };

    /**
     * Test de Hard Sync: un oscilador "slave" sincronizado por un "master".
     * 
     * El hard sync resetea la fase del slave cada vez que el master cruza
     * por cero en direcciÃ³n positiva. Esto produce:
     * - La frecuencia fundamental del output sigue al master
     * - El timbre es rico en armÃ³nicos (mÃ¡s que el slave solo)
     * - Diferentes ratios master/slave producen diferentes timbres
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.masterFrequency - Frecuencia del oscilador master (Hz)
     * @param {number} config.slaveFrequency - Frecuencia del oscilador slave (Hz)
     * @param {string} [config.masterWaveform='sine'] - Forma de onda del master
     * @param {string} [config.slaveWaveform='sawtooth'] - Forma de onda del slave
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testHardSync = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        masterWaveform = 'sine',
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync test: master ${masterWaveform}@${masterFrequency}Hz â†’ slave ${slaveWaveform}@${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador MASTER (proporciona la seÃ±al de sync)
      const master = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: masterWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      // Crear oscilador SLAVE (recibe sync en input 0)
      // NOTA: channelCountMode: 'explicit' + channelCount: 1 asegura que el input
      // tenga exactamente 1 canal incluso cuando el AudioWorklet lo procesa.
      const slave = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: slaveWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,  // Input 0 = sync input
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      // Conectar: master â†’ slave input 0 (sync)
      // El slave detecta flancos positivos del master y resetea su fase
      // IMPORTANTE: Usar connect(dest, outputIndex, inputIndex) para especificar
      // explÃ­citamente que conectamos al input 0 del worklet.
      master.connect(slave, 0, 0);

      // Solo el slave va a la salida
      slave.connect(offline.destination);

      // Renderizar
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;

      const samples = buffer.getChannelData(0);

      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      
      // Encontrar armÃ³nicos del master (la frecuencia fundamental debe ser del master)
      const masterHarmonics = findHarmonics(spectrum, masterFrequency, 10);
      
      // Encontrar armÃ³nicos del slave (para comparar)
      const slaveHarmonics = findHarmonics(spectrum, slaveFrequency, 5);

      // Contar armÃ³nicos significativos (> -40dB)
      const significantHarmonics = spectrum.filter(b => b.db > -40 && b.frequency > 50);

      // Calcular riqueza armÃ³nica (cuÃ¡ntos armÃ³nicos significativos hay)
      const harmonicRichness = significantHarmonics.length;

      // Calcular la energÃ­a en la frecuencia del master vs slave
      const masterBin = spectrum.find(b => Math.abs(b.frequency - masterFrequency) < 20);
      const slaveBin = spectrum.find(b => Math.abs(b.frequency - slaveFrequency) < 20);

      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      log(`Hard Sync render: ${renderTime.toFixed(1)}ms, dominant: ${dominant?.frequency.toFixed(1)}Hz`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, masterWaveform, slaveWaveform, duration },
        renderTime,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        masterHarmonics: masterHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        slaveHarmonics: slaveHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        masterEnergy: masterBin ? masterBin.magnitude : 0,
        slaveEnergy: slaveBin ? slaveBin.magnitude : 0,
        harmonicRichness,
        significantFreqs: significantHarmonics.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        })),
        rms,
        peak,
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * DiagnÃ³stico de Hard Sync: verifica que el input estÃ¡ llegando al worklet.
     * Renderiza master solo y captura cruces por cero.
     */
    window.diagnoseSyncInput = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        duration = 0.1,
        sampleRate = 44100
      } = config;

      log(`Diagnosing sync input: master=${masterFrequency}Hz, slave=${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      
      // Renderizar solo el master para ver su forma de onda
      const offlineMaster = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineMaster.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const masterAlone = new AudioWorkletNode(offlineMaster, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      masterAlone.parameters.get('frequency').value = masterFrequency;
      masterAlone.parameters.get('gain').value = 1.0;
      masterAlone.connect(offlineMaster.destination);

      const masterBuffer = await offlineMaster.startRendering();
      const masterSamples = masterBuffer.getChannelData(0);

      // Contar cruces por cero (flancos positivos)
      let positiveCrossings = 0;
      for (let i = 1; i < masterSamples.length; i++) {
        if (masterSamples[i] > 0 && masterSamples[i-1] <= 0) {
          positiveCrossings++;
        }
      }
      const expectedCrossings = Math.round(masterFrequency * duration);

      // Ahora renderizar master + slave para ver si hay diferencia
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slave = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      master.connect(slave, 0, 0);
      slave.connect(offlineSync.destination);

      const syncBuffer = await offlineSync.startRendering();
      const syncSamples = syncBuffer.getChannelData(0);

      // Renderizar slave sin sync para comparar
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveAlone = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      slaveAlone.parameters.get('frequency').value = slaveFrequency;
      slaveAlone.parameters.get('gain').value = 1.0;
      slaveAlone.connect(offlineNoSync.destination);

      const noSyncBuffer = await offlineNoSync.startRendering();
      const noSyncSamples = noSyncBuffer.getChannelData(0);

      // Comparar si hay diferencia entre sync y no-sync
      let diffSum = 0;
      for (let i = 0; i < syncSamples.length; i++) {
        diffSum += Math.abs(syncSamples[i] - noSyncSamples[i]);
      }
      const avgDiff = diffSum / syncSamples.length;

      log(`Diagnosis: masterCrossings=${positiveCrossings}/${expectedCrossings}, avgDiff=${avgDiff.toFixed(6)}`, avgDiff > 0.01 ? 'success' : 'error');

      return {
        masterFrequency,
        slaveFrequency,
        duration,
        positiveCrossings,
        expectedCrossings,
        crossingsMatch: Math.abs(positiveCrossings - expectedCrossings) <= 1,
        avgDiffWithWithoutSync: avgDiff,
        syncHasEffect: avgDiff > 0.01,
        masterSamples: Array.from(masterSamples.slice(0, 512)),
        syncSamples: Array.from(syncSamples.slice(0, 512)),
        noSyncSamples: Array.from(noSyncSamples.slice(0, 512))
      };
    };

    /**
     * Test comparativo: mismo oscilador con y sin hard sync.
     * Ãštil para verificar que el sync realmente modifica el timbre.
     */
    window.testHardSyncComparison = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync comparison: slave ${slaveWaveform}@${slaveFrequency}Hz with/without sync@${masterFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SIN SYNC: Solo el slave
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveOnly = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform }
      });
      slaveOnly.parameters.get('frequency').value = slaveFrequency;
      slaveOnly.parameters.get('gain').value = 1.0;
      slaveOnly.connect(offlineNoSync.destination);

      const bufferNoSync = await offlineNoSync.startRendering();
      const samplesNoSync = bufferNoSync.getChannelData(0);
      const spectrumNoSync = computeSpectrum(samplesNoSync, sampleRate);
      const dominantNoSync = findDominantFrequency(spectrumNoSync);
      const harmonicsNoSync = spectrumNoSync.filter(b => b.db > -40 && b.frequency > 50).length;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CON SYNC: Master + Slave sincronizado
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine', sinePurity: 1.0 }
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slaveSync = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform },
        numberOfInputs: 1,
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slaveSync.parameters.get('frequency').value = slaveFrequency;
      slaveSync.parameters.get('gain').value = 1.0;

      master.connect(slaveSync, 0, 0);  // Sync connection: output 0 â†’ input 0
      slaveSync.connect(offlineSync.destination);

      const bufferSync = await offlineSync.startRendering();
      const samplesSync = bufferSync.getChannelData(0);
      const spectrumSync = computeSpectrum(samplesSync, sampleRate);
      const dominantSync = findDominantFrequency(spectrumSync);
      const harmonicsSync = spectrumSync.filter(b => b.db > -40 && b.frequency > 50).length;

      log(`Comparison: noSync=${dominantNoSync?.frequency.toFixed(1)}Hz (${harmonicsNoSync} harmonics), sync=${dominantSync?.frequency.toFixed(1)}Hz (${harmonicsSync} harmonics)`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, slaveWaveform, duration },
        noSync: {
          dominantFrequency: dominantNoSync?.frequency || 0,
          harmonicCount: harmonicsNoSync,
          rms: calculateRMS(samplesNoSync),
          peak: calculatePeak(samplesNoSync)
        },
        withSync: {
          dominantFrequency: dominantSync?.frequency || 0,
          harmonicCount: harmonicsSync,
          rms: calculateRMS(samplesSync),
          peak: calculatePeak(samplesSync)
        },
        // Cambios esperados con sync:
        // 1. La frecuencia fundamental cambia de slaveFreq a masterFreq
        // 2. Generalmente mÃ¡s armÃ³nicos (timbre mÃ¡s rico)
        frequencyShift: (dominantSync?.frequency || 0) - (dominantNoSync?.frequency || 0),
        harmonicIncrease: harmonicsSync - harmonicsNoSync
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST DE MODULACIÃ“N CV 1V/OCTAVA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test de modulaciÃ³n de frecuencia por CV con estÃ¡ndar 1V/Octava.
     * 
     * Simula una seÃ±al de voltaje pasando por la matriz con un pin GREY
     * (precisiÃ³n Â±0.5%) hacia la entrada CV de frecuencia del oscilador.
     * 
     * El sistema Synthi 100 usa el estÃ¡ndar 1V/Octava:
     * - +1V de CV â†’ frecuencia Ã— 2 (1 octava arriba)
     * - -1V de CV â†’ frecuencia Ã· 2 (1 octava abajo)
     * 
     * Constantes del sistema (de voltageConstants.js):
     * - DIGITAL_TO_VOLTAGE = 4.0 (1.0 digital = 4V)
     * - VOLTS_PER_OCTAVE = 1.0
     * - Pin GREY = 100kÎ©, ganancia Ã—1
     * 
     * ConfiguraciÃ³n del oscilador (de oscillator.config.js):
     * - cvScale = 2
     * - octavesPerUnit = 0.5
     * - â†’ 1.0 digital = 1 octava
     * 
     * Para que 1V = 1 octava:
     * - 1V = 0.25 digital (1V / 4V)
     * - Necesitamos que el sistema amplifique Ã—4 para compensar
     * - Esto se logra ajustando cvScaleÃ—octavesPerUnit = 2 (en cents: Ã—4800)
     * 
     * En la implementaciÃ³n actual:
     * - cvScale=2, octavesPerUnit=0.5 â†’ centsGain = 1200
     * - 1.0 digital â†’ 1200 cents â†’ 1 octava
     * - Para 1V real (0.25 digital) â†’ necesitamos centsGain = 4800
     * 
     * Este test verifica el comportamiento con la calibraciÃ³n correcta para 1V/Oct.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.baseFrequency - Frecuencia base del oscilador (Hz)
     * @param {number} config.cvVoltage - Voltaje CV a aplicar (positivo o negativo)
     * @param {string} [config.waveform='sine'] - Forma de onda del oscilador
     * @param {string} [config.pinType='GREY'] - Tipo de pin (GREY para precisiÃ³n)
     * @param {boolean} [config.rangeLow=false] - true para rango LO (sub-audio)
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis con frecuencias medidas
     */
    window.testFrequencyCV = async function(config) {
      const {
        baseFrequency = 261,  // C4 (punto central del Synthi)
        cvVoltage = 1.0,      // +1V = +1 octava
        waveform = 'sine',
        pinType = 'GREY',     // Pin de precisiÃ³n
        rangeLow = false,     // HI por defecto
        duration = 0.5,
        sampleRate = 44100
      } = config;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CONSTANTES DEL SISTEMA (replicadas de voltageConstants.js)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const DIGITAL_TO_VOLTAGE = 4.0;  // 1.0 digital = 4V
      const VOLTS_PER_OCTAVE = 1.0;    // EstÃ¡ndar V/Oct
      
      // Resistencias de pines (Rf = 100kÎ© estÃ¡ndar)
      const PIN_GAINS = {
        WHITE: 1.0,    // 100kÎ© / 100kÎ© = 1
        GREY: 1.0,     // 100kÎ© / 100kÎ© = 1 (precisiÃ³n)
        GREEN: 1.47,   // 100kÎ© / 68kÎ© â‰ˆ 1.47
        RED: 37.04,    // 100kÎ© / 2.7kÎ© â‰ˆ 37
        BLUE: 10.0,    // 100kÎ© / 10kÎ© = 10
        YELLOW: 4.55,  // 100kÎ© / 22kÎ© â‰ˆ 4.55
        CYAN: 0.4,     // 100kÎ© / 250kÎ© = 0.4
        PURPLE: 0.1    // 100kÎ© / 1MÎ© = 0.1
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALIBRACIÃ“N PARA 1V/OCTAVA REAL
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // El estÃ¡ndar es: 1V de entrada â†’ 1 octava de cambio
      // 
      // ConversiÃ³n voltaje â†’ digital: cvVoltage / DIGITAL_TO_VOLTAGE
      // Ejemplo: 1V / 4V = 0.25 digital
      //
      // Para que 0.25 digital = 1 octava (1200 cents):
      // centsGain = 1200 / 0.25 = 4800 cents por unidad digital
      //
      // Con pin GREY (ganancia Ã—1):
      // centsGain = VOLTS_PER_OCTAVE Ã— DIGITAL_TO_VOLTAGE Ã— 1200 = 4800
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const pinGain = PIN_GAINS[pinType] || 1.0;
      
      // Ganancia total para el sistema CV del oscilador
      // Esta es la calibraciÃ³n correcta para 1V/Octava
      const centsPerVolt = 1200;  // 1 octava = 1200 cents
      const centsGain = centsPerVolt * DIGITAL_TO_VOLTAGE * pinGain;
      // Con GREY: 1200 Ã— 4 Ã— 1 = 4800 cents por unidad digital
      
      log(`CV Test: ${cvVoltage}V via ${pinType} pin (gain=${pinGain}Ã—) to ${waveform}@${baseFrequency}Hz`);
      log(`  centsGain=${centsGain}, expected shift=${cvVoltage * centsPerVolt} cents`);

      const length = Math.ceil(sampleRate * duration);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR SIN CV (frecuencia base)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineBase = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineBase.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscBase = new AudioWorkletNode(offlineBase, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscBase.parameters.get('frequency').value = baseFrequency;
      oscBase.parameters.get('gain').value = 1.0;
      oscBase.parameters.get('detune').value = 0;  // Sin CV
      oscBase.connect(offlineBase.destination);
      
      const bufferBase = await offlineBase.startRendering();
      const samplesBase = bufferBase.getChannelData(0);
      const spectrumBase = computeSpectrum(samplesBase, sampleRate);
      const dominantBase = findDominantFrequency(spectrumBase);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR CON CV (frecuencia modulada)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineCV = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineCV.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscCV = new AudioWorkletNode(offlineCV, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscCV.parameters.get('frequency').value = baseFrequency;
      oscCV.parameters.get('gain').value = 1.0;
      
      // Aplicar CV: convertir voltios â†’ digital â†’ cents
      // 1V â†’ 0.25 digital â†’ 0.25 Ã— 4800 = 1200 cents = 1 octava
      const cvDigital = cvVoltage / DIGITAL_TO_VOLTAGE;  // Voltios a digital
      const cvCents = cvDigital * centsGain;             // Digital a cents
      oscCV.parameters.get('detune').value = cvCents;
      
      log(`  cvDigital=${cvDigital.toFixed(4)}, cvCents=${cvCents.toFixed(1)}`);
      
      oscCV.connect(offlineCV.destination);
      
      const bufferCV = await offlineCV.startRendering();
      const samplesCV = bufferCV.getChannelData(0);
      const spectrumCV = computeSpectrum(samplesCV, sampleRate);
      const dominantCV = findDominantFrequency(spectrumCV);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALCULAR RESULTADOS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const measuredBaseFreq = dominantBase?.frequency || 0;
      const measuredCVFreq = dominantCV?.frequency || 0;
      
      // Calcular ratio de frecuencias (deberÃ­a ser 2 para +1V, 0.5 para -1V)
      const frequencyRatio = measuredCVFreq / measuredBaseFreq;
      
      // Calcular octavas de cambio: log2(ratio)
      const octavesChange = Math.log2(frequencyRatio);
      
      // Frecuencia esperada segÃºn 1V/Oct
      const expectedFreq = baseFrequency * Math.pow(2, cvVoltage / VOLTS_PER_OCTAVE);
      
      log(`  Result: base=${measuredBaseFreq.toFixed(1)}Hz, withCV=${measuredCVFreq.toFixed(1)}Hz`, 'success');
      log(`  Ratio=${frequencyRatio.toFixed(4)}, octaves=${octavesChange.toFixed(4)}, expected=${expectedFreq.toFixed(1)}Hz`);

      return {
        config: { baseFrequency, cvVoltage, waveform, pinType, rangeLow },
        calibration: {
          pinGain,
          centsGain,
          cvDigital,
          cvCents
        },
        baseFrequency: {
          requested: baseFrequency,
          measured: measuredBaseFreq,
          rms: calculateRMS(samplesBase),
          peak: calculatePeak(samplesBase)
        },
        withCV: {
          expected: expectedFreq,
          measured: measuredCVFreq,
          rms: calculateRMS(samplesCV),
          peak: calculatePeak(samplesCV)
        },
        analysis: {
          frequencyRatio,
          octavesChange,
          expectedOctaves: cvVoltage / VOLTS_PER_OCTAVE,
          error: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)),
          errorCents: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)) * 1200
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INICIALIZACIÃ“N
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function init() {
      try {
        log('Verificando soporte Web Audio...');
        
        if (!window.AudioContext && !window.webkitAudioContext) {
          throw new Error('Web Audio API no soportada');
        }
        
        if (!window.OfflineAudioContext) {
          throw new Error('OfflineAudioContext no soportado');
        }
        
        // Test rÃ¡pido de AudioWorklet
        const testCtx = new OfflineAudioContext(1, 1024, 44100);
        if (!testCtx.audioWorklet) {
          throw new Error('AudioWorklet no soportado');
        }
        
        log('Web Audio API disponible', 'success');
        log('OfflineAudioContext disponible', 'success');
        log('AudioWorklet disponible', 'success');
        
        setStatus('âœ… Harness listo para tests de audio', 'ready');
        
        // Marcar como listo para Playwright
        window.__AUDIO_HARNESS_READY__ = true;
        
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        setStatus(`âŒ Error: ${error.message}`, 'error');
        window.__AUDIO_HARNESS_READY__ = false;
      }
    }

    init();
  </script>
</body>
</html>
