<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SynthiGME Audio Test Harness</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 2rem auto;
      padding: 1rem;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #00d9ff; }
    .status { 
      padding: 0.5rem 1rem; 
      border-radius: 4px; 
      margin: 0.5rem 0;
    }
    .ready { background: #0f5132; }
    .loading { background: #664d03; }
    .error { background: #842029; }
    #log {
      background: #0d0d0d;
      padding: 1rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
    .log-entry { margin: 0.25rem 0; }
    .log-entry.info { color: #6c757d; }
    .log-entry.success { color: #198754; }
    .log-entry.error { color: #dc3545; }
  </style>
</head>
<body>
  <h1>ğŸ›ï¸ SynthiGME Audio Test Harness</h1>
  
  <div id="status" class="status loading">Cargando worklets...</div>
  
  <div id="log"></div>

  <script type="module">
    /**
     * Audio Test Harness
     * 
     * Este archivo se carga en Playwright y expone funciones globales
     * para ejecutar tests de audio con Web Audio API real.
     * 
     * Los tests llaman a estas funciones via page.evaluate().
     */

    const log = (msg, type = 'info') => {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toISOString().slice(11, 23)}] ${msg}`;
      document.getElementById('log').appendChild(entry);
      console.log(`[AudioHarness] ${msg}`);
    };

    const setStatus = (msg, type) => {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = `status ${type}`;
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS DE ANÃLISIS ESPECTRAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Calcula el espectro de magnitud usando DFT simple (mÃ¡s lento pero confiable).
     * Solo calcula los bins necesarios para el anÃ¡lisis.
     */
    function computeSpectrum(samples, sampleRate) {
      const N = samples.length;
      const spectrum = [];
      
      // Solo calcular hasta Nyquist y con resoluciÃ³n razonable
      const maxBins = Math.min(N / 2, 2048);
      const binStep = Math.max(1, Math.floor(N / 2 / maxBins));
      
      for (let k = 1; k < maxBins; k++) {
        const binIndex = k * binStep;
        let re = 0;
        let im = 0;
        
        // DFT para este bin especÃ­fico
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * binIndex * n / N;
          re += samples[n] * Math.cos(angle);
          im += samples[n] * Math.sin(angle);
        }
        
        const magnitude = Math.sqrt(re * re + im * im) / N;
        const db = 20 * Math.log10(magnitude + 1e-10);
        const frequency = binIndex * sampleRate / N;
        
        spectrum.push({
          bin: binIndex,
          frequency,
          magnitude,
          db
        });
      }
      
      return spectrum;
    }

    /**
     * VersiÃ³n rÃ¡pida: usa zero-crossing para estimar frecuencia
     * y picos para anÃ¡lisis bÃ¡sico de armÃ³nicos.
     */
    function analyzeSignalFast(samples, sampleRate) {
      // Estimar frecuencia por zero crossings
      let crossings = 0;
      for (let i = 1; i < samples.length; i++) {
        if ((samples[i - 1] < 0 && samples[i] >= 0)) {
          crossings++;
        }
      }
      const duration = samples.length / sampleRate;
      const estimatedFreq = crossings / duration;
      
      // Calcular RMS y peak
      let sum = 0;
      let peak = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
        if (Math.abs(samples[i]) > peak) peak = Math.abs(samples[i]);
      }
      const rms = Math.sqrt(sum / samples.length);
      
      return {
        estimatedFreq,
        rms,
        peak
      };
    }

    /**
     * Encuentra la frecuencia dominante en el espectro.
     */
    function findDominantFrequency(spectrum, minDb = -80) {
      let maxMag = 0;
      let dominant = null;
      
      // Ignorar DC (bin 0) y frecuencias muy bajas
      for (let i = 1; i < spectrum.length; i++) {
        const bin = spectrum[i];
        if (bin.magnitude > maxMag && bin.frequency > 10) {
          maxMag = bin.magnitude;
          dominant = bin;
        }
      }
      
      return dominant;
    }

    /**
     * Encuentra armÃ³nicos de una frecuencia fundamental.
     */
    function findHarmonics(spectrum, fundamental, count = 5, tolerance = 5) {
      const harmonics = [];
      
      for (let n = 1; n <= count; n++) {
        const targetFreq = fundamental * n;
        let best = null;
        let bestDiff = Infinity;
        
        for (const bin of spectrum) {
          const diff = Math.abs(bin.frequency - targetFreq);
          if (diff < tolerance && diff < bestDiff) {
            bestDiff = diff;
            best = bin;
          }
        }
        
        harmonics.push({
          harmonic: n,
          expected: targetFreq,
          found: best
        });
      }
      
      return harmonics;
    }

    /**
     * Calcula la DistorsiÃ³n ArmÃ³nica Total (THD).
     */
    function measureTHD(spectrum, fundamental, numHarmonics = 5) {
      const harmonics = findHarmonics(spectrum, fundamental, numHarmonics + 1);
      
      const fundamentalMag = harmonics[0]?.found?.magnitude || 0;
      if (fundamentalMag === 0) return null;
      
      let harmonicPower = 0;
      for (let i = 1; i < harmonics.length; i++) {
        const mag = harmonics[i]?.found?.magnitude || 0;
        harmonicPower += mag * mag;
      }
      
      return Math.sqrt(harmonicPower) / fundamentalMag * 100; // Porcentaje
    }

    /**
     * Calcula RMS de una seÃ±al.
     */
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
      }
      return Math.sqrt(sum / samples.length);
    }

    /**
     * Calcula el pico de una seÃ±al.
     */
    function calculatePeak(samples) {
      let max = 0;
      for (let i = 0; i < samples.length; i++) {
        const abs = Math.abs(samples[i]);
        if (abs > max) max = abs;
      }
      return max;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FUNCIONES DE TEST EXPUESTAS GLOBALMENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Renderiza audio de un oscilador con OfflineAudioContext.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {string} config.waveform - Tipo de onda: 'sine'|'sawtooth'|'triangle'|'pulse'
     * @param {number} config.frequency - Frecuencia en Hz
     * @param {number} config.duration - DuraciÃ³n en segundos
     * @param {number} [config.pulseWidth=0.5] - Ancho de pulso (0.01-0.99)
     * @param {number} [config.symmetry=0.5] - SimetrÃ­a del sine (0-1)
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testSynthOscillator = async function(config) {
      const {
        waveform = 'sine',
        frequency = 440,
        duration = 0.5,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering ${waveform} @ ${frequency}Hz, duration=${duration}s`);

      // Crear OfflineAudioContext
      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      log('Worklet registrado');

      // Crear nodo de oscilador
      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform,
          sineShapeAttenuation: 0,  // Sin atenuaciÃ³n para tests de forma pura
          sinePurity: 1.0            // Seno puro en centro
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('gain').value = 1.0;

      // Conectar a destino
      oscillator.connect(offline.destination);

      // Renderizar
      log('Iniciando render...');
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;
      log(`Render completado en ${renderTime.toFixed(1)}ms`, 'success');

      // Obtener samples
      const samples = buffer.getChannelData(0);
      
      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const harmonics = findHarmonics(spectrum, frequency, 10);
      const thd = measureTHD(spectrum, frequency, 5);
      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      // Verificar forma de onda (primeros N samples para anÃ¡lisis de fase)
      const phaseAnalysis = {
        startValue: samples[0],
        quarterCycle: samples[Math.floor(sampleRate / frequency / 4)],
        halfCycle: samples[Math.floor(sampleRate / frequency / 2)],
        threeQuarterCycle: samples[Math.floor(sampleRate / frequency * 0.75)]
      };

      return {
        config,
        renderTime,
        sampleCount: samples.length,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        harmonics: harmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? {
            frequency: h.found.frequency,
            magnitude: h.found.magnitude,
            db: h.found.db
          } : null
        })),
        thd,
        rms,
        peak,
        phaseAnalysis,
        // Incluir algunos samples para verificaciÃ³n visual
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * Renderiza audio con mÃºltiples formas de onda simultÃ¡neas (modo multi).
     */
    window.testSynthOscillatorMulti = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sineLevel = 1,
        sawLevel = 0,
        triLevel = 0,
        pulseLevel = 0,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering multi-waveform @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 2,  // 2 canales: sine+saw, tri+pulse
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'multi',
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 2,
        outputChannelCount: [1, 1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('sineLevel').value = sineLevel;
      oscillator.parameters.get('sawLevel').value = sawLevel;
      oscillator.parameters.get('triLevel').value = triLevel;
      oscillator.parameters.get('pulseLevel').value = pulseLevel;

      // Crear merger para capturar ambos canales
      const merger = offline.createChannelMerger(2);
      oscillator.connect(merger, 0, 0);  // sine+saw â†’ canal 0
      oscillator.connect(merger, 1, 1);  // tri+pulse â†’ canal 1
      merger.connect(offline.destination);

      const buffer = await offline.startRendering();
      
      const channel0 = buffer.getChannelData(0);  // sine + saw
      const channel1 = buffer.getChannelData(1);  // tri + pulse

      return {
        config,
        channel0: {
          rms: calculateRMS(channel0),
          peak: calculatePeak(channel0),
          spectrum: computeSpectrum(channel0, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel0.slice(0, 256))
        },
        channel1: {
          rms: calculateRMS(channel1),
          peak: calculatePeak(channel1),
          spectrum: computeSpectrum(channel1, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel1.slice(0, 256))
        }
      };
    };

    /**
     * Renderiza audio a travÃ©s de una cadena de nodos (simula matriz).
     * Ãštil para tests de routing y ganancias.
     */
    window.testSignalRouting = async function(config) {
      const {
        sourceFrequency = 440,
        sourceWaveform = 'sine',
        gains = [1.0],  // Array de ganancias a aplicar en cadena
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Routing test: ${sourceWaveform}@${sourceFrequency}Hz through ${gains.length} gain stages`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador fuente
      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: sourceWaveform }
      });
      osc.parameters.get('frequency').value = sourceFrequency;
      osc.parameters.get('gain').value = 1.0;

      // Crear cadena de ganancias (simulando pines de matriz)
      let lastNode = osc;
      const gainNodes = [];
      
      for (const gainValue of gains) {
        const gainNode = offline.createGain();
        gainNode.gain.value = gainValue;
        lastNode.connect(gainNode);
        lastNode = gainNode;
        gainNodes.push({ requestedGain: gainValue, actualGain: gainNode.gain.value });
      }

      lastNode.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Calcular ganancia total esperada vs real
      const expectedTotalGain = gains.reduce((a, b) => a * b, 1.0);
      const actualPeak = calculatePeak(samples);

      return {
        config,
        gainNodes,
        expectedTotalGain,
        actualPeak,
        rms: calculateRMS(samples),
        spectrum: computeSpectrum(samples, sampleRate).slice(0, 200)  // MÃ¡s bins para mejor resoluciÃ³n
      };
    };

    /**
     * Test de latencia: mide el tiempo desde trigger hasta primer sample no-cero.
     */
    window.testLatency = async function(config) {
      const {
        frequency = 1000,
        sampleRate = 44100,
        duration = 0.1
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'pulse' }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Encontrar primer sample con seÃ±al significativa
      let firstNonZeroIndex = -1;
      const threshold = 0.001;
      for (let i = 0; i < samples.length; i++) {
        if (Math.abs(samples[i]) > threshold) {
          firstNonZeroIndex = i;
          break;
        }
      }

      const latencySamples = firstNonZeroIndex;
      const latencyMs = latencySamples >= 0 ? (latencySamples / sampleRate * 1000) : null;

      return {
        latencySamples,
        latencyMs,
        firstSamples: Array.from(samples.slice(0, 20))
      };
    };

    /**
     * Test de anti-aliasing: verifica que no hay frecuencias espurias sobre Nyquist.
     */
    window.testAntiAliasing = async function(config) {
      const {
        frequency = 10000,  // Alta frecuencia para provocar aliasing
        waveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Anti-aliasing test: ${waveform} @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);
      const spectrum = computeSpectrum(samples, sampleRate);

      // Encontrar frecuencias significativas (> -40dB)
      const significantFreqs = spectrum.filter(bin => bin.db > -40);
      
      // Calcular quÃ© armÃ³nicos deberÃ­an existir vs cuÃ¡les estÃ¡n aliasados
      const nyquist = sampleRate / 2;
      const expectedHarmonics = [];
      const aliasedHarmonics = [];
      
      for (let n = 1; n <= 20; n++) {
        const harmonicFreq = frequency * n;
        if (harmonicFreq < nyquist) {
          expectedHarmonics.push({ n, frequency: harmonicFreq });
        } else {
          // Frecuencia aliasada = |freq - N * sampleRate|
          const aliasedFreq = Math.abs(harmonicFreq - Math.round(harmonicFreq / sampleRate) * sampleRate);
          aliasedHarmonics.push({ n, original: harmonicFreq, aliased: aliasedFreq });
        }
      }

      // Verificar que no hay energÃ­a significativa en frecuencias aliasadas
      const aliasingDetected = [];
      for (const alias of aliasedHarmonics) {
        const found = spectrum.find(bin => 
          Math.abs(bin.frequency - alias.aliased) < 20 && bin.db > -50
        );
        if (found) {
          aliasingDetected.push({
            ...alias,
            detectedMagnitude: found.magnitude,
            detectedDb: found.db
          });
        }
      }

      return {
        config,
        nyquist,
        expectedHarmonics: expectedHarmonics.length,
        aliasedHarmonics: aliasedHarmonics.length,
        aliasingDetected,
        hasAliasing: aliasingDetected.length > 0,
        significantFreqs: significantFreqs.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        }))
      };
    };

    /**
     * Test de Niveles de Voltaje de Salida por Forma de Onda
     * 
     * Verifica que las amplitudes relativas entre formas de onda cumplen
     * los ratios especificados en el Manual TÃ©cnico Datanomics (1982):
     * 
     * | Forma      | Voltaje   | Ratio vs Seno |
     * |------------|-----------|---------------|
     * | Seno       | 8.0V p-p  | 1.000         |
     * | Sierra     | 6.2V p-p  | 0.775         |
     * | TriÃ¡ngulo  | 8.1V p-p  | 1.0125        |
     * | Pulso      | 8.1V p-p  | 1.0125        |
     * | Cuspoide   | 0.5V p-p  | 0.0625 (1/16) |
     * 
     * NOTA: Cuspoide = Seno con symmetry=0 o symmetry=1 y sineShapeAttenuation=1
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} [config.frequency=440] - Frecuencia de test (Hz)
     * @param {number} [config.duration=0.5] - DuraciÃ³n de render (s)
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @param {boolean} [config.testCusp=false] - Si debe testear cuspoide
     * @returns {Object} Amplitudes y ratios medidos
     */
    window.testWaveformAmplitudes = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sampleRate = 44100,
        testCusp = false
      } = config;

      log(`Testing waveform amplitudes @ ${frequency}Hz, testCusp=${testCusp}`);

      const length = Math.ceil(sampleRate * duration);
      const waveforms = ['sine', 'sawtooth', 'triangle', 'pulse'];
      const results = {};

      // Medir amplitud de cada forma de onda bÃ¡sica
      for (const waveform of waveforms) {
        const offline = new OfflineAudioContext({
          numberOfChannels: 1,
          length,
          sampleRate
        });

        await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

        const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
          processorOptions: {
            mode: 'single',
            waveform,
            sineShapeAttenuation: 0,  // Sin atenuaciÃ³n de forma
            sinePurity: 1.0            // Seno puro
          },
          numberOfInputs: 1,
          numberOfOutputs: 1,
          outputChannelCount: [1]
        });

        oscillator.parameters.get('frequency').value = frequency;
        oscillator.parameters.get('pulseWidth').value = 0.5;  // Duty 50% para pulse
        oscillator.parameters.get('symmetry').value = 0.5;    // Centro para sine
        oscillator.parameters.get('gain').value = 1.0;

        oscillator.connect(offline.destination);

        const buffer = await offline.startRendering();
        const samples = buffer.getChannelData(0);

        results[waveform] = {
          peak: calculatePeak(samples),
          rms: calculateRMS(samples)
        };

        log(`  ${waveform}: peak=${results[waveform].peak.toFixed(4)}, rms=${results[waveform].rms.toFixed(4)}`);
      }

      // Testear cuspoide si se solicita (seno con symmetry extrema y atenuaciÃ³n)
      if (testCusp) {
        // Cuspoide = seno con symmetry=0 (o 1) y sineShapeAttenuation=1
        const offlineCusp = new OfflineAudioContext({
          numberOfChannels: 1,
          length,
          sampleRate
        });

        await offlineCusp.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

        const cuspOscillator = new AudioWorkletNode(offlineCusp, 'synth-oscillator', {
          processorOptions: {
            mode: 'single',
            waveform: 'sine',
            sineShapeAttenuation: 1.0,  // AtenuaciÃ³n completa activada
            sinePurity: 1.0
          },
          numberOfInputs: 1,
          numberOfOutputs: 1,
          outputChannelCount: [1]
        });

        cuspOscillator.parameters.get('frequency').value = frequency;
        cuspOscillator.parameters.get('symmetry').value = 0;  // Extremo = cuspoide
        cuspOscillator.parameters.get('gain').value = 1.0;

        cuspOscillator.connect(offlineCusp.destination);

        const cuspBuffer = await offlineCusp.startRendering();
        const cuspSamples = cuspBuffer.getChannelData(0);

        results.cusp = {
          peak: calculatePeak(cuspSamples),
          rms: calculateRMS(cuspSamples)
        };

        log(`  cusp: peak=${results.cusp.peak.toFixed(4)}, rms=${results.cusp.rms.toFixed(4)}`);
      }

      // Calcular ratios respecto al seno
      const sinePeak = results.sine.peak;
      const ratios = {};

      for (const [waveform, data] of Object.entries(results)) {
        ratios[waveform] = {
          vsReference: data.peak / sinePeak,  // Ratio vs seno
          peakToRms: data.peak / data.rms     // Crest factor
        };
      }

      // Voltajes esperados segÃºn Datanomics 1982 (normalizados a seno=1.0)
      const expectedRatios = {
        sine: 8.0 / 8.0,       // 1.0000
        sawtooth: 6.2 / 8.0,   // 0.7750
        triangle: 8.1 / 8.0,   // 1.0125
        pulse: 8.1 / 8.0,      // 1.0125
        cusp: 0.5 / 8.0        // 0.0625 (1/16)
      };

      return {
        config,
        measurements: results,
        ratios,
        expectedRatios,
        sinePeak,  // Para referencia
        // Diferencias para validaciÃ³n
        differences: Object.fromEntries(
          Object.entries(ratios).map(([waveform, data]) => [
            waveform,
            {
              measured: data.vsReference,
              expected: expectedRatios[waveform],
              error: data.vsReference - expectedRatios[waveform],
              errorPercent: ((data.vsReference - expectedRatios[waveform]) / expectedRatios[waveform] * 100)
            }
          ])
        )
      };
    };

    /**
     * Test especÃ­fico de atenuaciÃ³n cuspoide vs seno puro
     * 
     * Verifica el ratio de atenuaciÃ³n 8:1 documentado en el manual:
     * - Seno puro (symmetry=0.5): amplitud completa
     * - Cuspoide (symmetry=0 o 1): amplitud reducida a 1/8
     * 
     * @param {Object} config - ConfiguraciÃ³n
     * @returns {Object} ComparaciÃ³n seno vs cuspoide
     */
    window.testCuspAttenuation = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Testing cusp attenuation @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);

      // === SENO PURO (symmetry=0.5, sin atenuaciÃ³n) ===
      const offlinePure = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlinePure.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const pureSine = new AudioWorkletNode(offlinePure, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'sine',
          sineShapeAttenuation: 1.0,  // AtenuaciÃ³n activa (pero no aplica en centro)
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      pureSine.parameters.get('frequency').value = frequency;
      pureSine.parameters.get('symmetry').value = 0.5;  // Centro = seno puro
      pureSine.parameters.get('gain').value = 1.0;
      pureSine.connect(offlinePure.destination);

      const pureBuf = await offlinePure.startRendering();
      const pureSamples = pureBuf.getChannelData(0);

      // === CUSPOIDE (symmetry=0, con atenuaciÃ³n) ===
      const offlineCusp = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineCusp.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const cuspSine = new AudioWorkletNode(offlineCusp, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'sine',
          sineShapeAttenuation: 1.0,  // AtenuaciÃ³n completa
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      cuspSine.parameters.get('frequency').value = frequency;
      cuspSine.parameters.get('symmetry').value = 0;  // Extremo = cuspoide mÃ¡xima
      cuspSine.parameters.get('gain').value = 1.0;
      cuspSine.connect(offlineCusp.destination);

      const cuspBuf = await offlineCusp.startRendering();
      const cuspSamples = cuspBuf.getChannelData(0);

      // Calcular mÃ©tricas
      const purePeak = calculatePeak(pureSamples);
      const cuspPeak = calculatePeak(cuspSamples);
      const pureRms = calculateRMS(pureSamples);
      const cuspRms = calculateRMS(cuspSamples);

      // Ratio medido vs esperado (8:1 = 0.125)
      const measuredRatio = cuspPeak / purePeak;
      const expectedRatio = 0.125;  // 1/8 = 0.5V / 4V segÃºn manual

      log(`  Pure sine: peak=${purePeak.toFixed(4)}, rms=${pureRms.toFixed(4)}`);
      log(`  Cusp form: peak=${cuspPeak.toFixed(4)}, rms=${cuspRms.toFixed(4)}`);
      log(`  Ratio cusp/pure: ${measuredRatio.toFixed(4)} (expected: ${expectedRatio})`);

      return {
        config,
        pureSine: {
          peak: purePeak,
          rms: pureRms
        },
        cuspForm: {
          peak: cuspPeak,
          rms: cuspRms
        },
        attenuation: {
          measuredRatio,
          expectedRatio,
          inverseRatio: 1 / measuredRatio,  // DeberÃ­a ser ~8
          error: measuredRatio - expectedRatio,
          errorPercent: (measuredRatio - expectedRatio) / expectedRatio * 100
        }
      };
    };

    /**
     * Test de Hard Sync: un oscilador "slave" sincronizado por un "master".
     * 
     * El hard sync resetea la fase del slave cada vez que el master cruza
     * por cero en direcciÃ³n positiva. Esto produce:
     * - La frecuencia fundamental del output sigue al master
     * - El timbre es rico en armÃ³nicos (mÃ¡s que el slave solo)
     * - Diferentes ratios master/slave producen diferentes timbres
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.masterFrequency - Frecuencia del oscilador master (Hz)
     * @param {number} config.slaveFrequency - Frecuencia del oscilador slave (Hz)
     * @param {string} [config.masterWaveform='sine'] - Forma de onda del master
     * @param {string} [config.slaveWaveform='sawtooth'] - Forma de onda del slave
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testHardSync = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        masterWaveform = 'sine',
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync test: master ${masterWaveform}@${masterFrequency}Hz â†’ slave ${slaveWaveform}@${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador MASTER (proporciona la seÃ±al de sync)
      const master = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: masterWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      // Crear oscilador SLAVE (recibe sync en input 0)
      // NOTA: channelCountMode: 'explicit' + channelCount: 1 asegura que el input
      // tenga exactamente 1 canal incluso cuando el AudioWorklet lo procesa.
      const slave = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: slaveWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,  // Input 0 = sync input
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      // Conectar: master â†’ slave input 0 (sync)
      // El slave detecta flancos positivos del master y resetea su fase
      // IMPORTANTE: Usar connect(dest, outputIndex, inputIndex) para especificar
      // explÃ­citamente que conectamos al input 0 del worklet.
      master.connect(slave, 0, 0);

      // Solo el slave va a la salida
      slave.connect(offline.destination);

      // Renderizar
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;

      const samples = buffer.getChannelData(0);

      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      
      // Encontrar armÃ³nicos del master (la frecuencia fundamental debe ser del master)
      const masterHarmonics = findHarmonics(spectrum, masterFrequency, 10);
      
      // Encontrar armÃ³nicos del slave (para comparar)
      const slaveHarmonics = findHarmonics(spectrum, slaveFrequency, 5);

      // Contar armÃ³nicos significativos (> -40dB)
      const significantHarmonics = spectrum.filter(b => b.db > -40 && b.frequency > 50);

      // Calcular riqueza armÃ³nica (cuÃ¡ntos armÃ³nicos significativos hay)
      const harmonicRichness = significantHarmonics.length;

      // Calcular la energÃ­a en la frecuencia del master vs slave
      const masterBin = spectrum.find(b => Math.abs(b.frequency - masterFrequency) < 20);
      const slaveBin = spectrum.find(b => Math.abs(b.frequency - slaveFrequency) < 20);

      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      log(`Hard Sync render: ${renderTime.toFixed(1)}ms, dominant: ${dominant?.frequency.toFixed(1)}Hz`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, masterWaveform, slaveWaveform, duration },
        renderTime,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        masterHarmonics: masterHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        slaveHarmonics: slaveHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        masterEnergy: masterBin ? masterBin.magnitude : 0,
        slaveEnergy: slaveBin ? slaveBin.magnitude : 0,
        harmonicRichness,
        significantFreqs: significantHarmonics.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        })),
        rms,
        peak,
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * DiagnÃ³stico de Hard Sync: verifica que el input estÃ¡ llegando al worklet.
     * Renderiza master solo y captura cruces por cero.
     */
    window.diagnoseSyncInput = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        duration = 0.1,
        sampleRate = 44100
      } = config;

      log(`Diagnosing sync input: master=${masterFrequency}Hz, slave=${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      
      // Renderizar solo el master para ver su forma de onda
      const offlineMaster = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineMaster.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const masterAlone = new AudioWorkletNode(offlineMaster, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      masterAlone.parameters.get('frequency').value = masterFrequency;
      masterAlone.parameters.get('gain').value = 1.0;
      masterAlone.connect(offlineMaster.destination);

      const masterBuffer = await offlineMaster.startRendering();
      const masterSamples = masterBuffer.getChannelData(0);

      // Contar cruces por cero (flancos positivos)
      let positiveCrossings = 0;
      for (let i = 1; i < masterSamples.length; i++) {
        if (masterSamples[i] > 0 && masterSamples[i-1] <= 0) {
          positiveCrossings++;
        }
      }
      const expectedCrossings = Math.round(masterFrequency * duration);

      // Ahora renderizar master + slave para ver si hay diferencia
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slave = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      master.connect(slave, 0, 0);
      slave.connect(offlineSync.destination);

      const syncBuffer = await offlineSync.startRendering();
      const syncSamples = syncBuffer.getChannelData(0);

      // Renderizar slave sin sync para comparar
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveAlone = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      slaveAlone.parameters.get('frequency').value = slaveFrequency;
      slaveAlone.parameters.get('gain').value = 1.0;
      slaveAlone.connect(offlineNoSync.destination);

      const noSyncBuffer = await offlineNoSync.startRendering();
      const noSyncSamples = noSyncBuffer.getChannelData(0);

      // Comparar si hay diferencia entre sync y no-sync
      let diffSum = 0;
      for (let i = 0; i < syncSamples.length; i++) {
        diffSum += Math.abs(syncSamples[i] - noSyncSamples[i]);
      }
      const avgDiff = diffSum / syncSamples.length;

      log(`Diagnosis: masterCrossings=${positiveCrossings}/${expectedCrossings}, avgDiff=${avgDiff.toFixed(6)}`, avgDiff > 0.01 ? 'success' : 'error');

      return {
        masterFrequency,
        slaveFrequency,
        duration,
        positiveCrossings,
        expectedCrossings,
        crossingsMatch: Math.abs(positiveCrossings - expectedCrossings) <= 1,
        avgDiffWithWithoutSync: avgDiff,
        syncHasEffect: avgDiff > 0.01,
        masterSamples: Array.from(masterSamples.slice(0, 512)),
        syncSamples: Array.from(syncSamples.slice(0, 512)),
        noSyncSamples: Array.from(noSyncSamples.slice(0, 512))
      };
    };

    /**
     * Test comparativo: mismo oscilador con y sin hard sync.
     * Ãštil para verificar que el sync realmente modifica el timbre.
     */
    window.testHardSyncComparison = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync comparison: slave ${slaveWaveform}@${slaveFrequency}Hz with/without sync@${masterFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SIN SYNC: Solo el slave
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveOnly = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform }
      });
      slaveOnly.parameters.get('frequency').value = slaveFrequency;
      slaveOnly.parameters.get('gain').value = 1.0;
      slaveOnly.connect(offlineNoSync.destination);

      const bufferNoSync = await offlineNoSync.startRendering();
      const samplesNoSync = bufferNoSync.getChannelData(0);
      const spectrumNoSync = computeSpectrum(samplesNoSync, sampleRate);
      const dominantNoSync = findDominantFrequency(spectrumNoSync);
      const harmonicsNoSync = spectrumNoSync.filter(b => b.db > -40 && b.frequency > 50).length;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CON SYNC: Master + Slave sincronizado
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine', sinePurity: 1.0 }
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slaveSync = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform },
        numberOfInputs: 1,
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slaveSync.parameters.get('frequency').value = slaveFrequency;
      slaveSync.parameters.get('gain').value = 1.0;

      master.connect(slaveSync, 0, 0);  // Sync connection: output 0 â†’ input 0
      slaveSync.connect(offlineSync.destination);

      const bufferSync = await offlineSync.startRendering();
      const samplesSync = bufferSync.getChannelData(0);
      const spectrumSync = computeSpectrum(samplesSync, sampleRate);
      const dominantSync = findDominantFrequency(spectrumSync);
      const harmonicsSync = spectrumSync.filter(b => b.db > -40 && b.frequency > 50).length;

      log(`Comparison: noSync=${dominantNoSync?.frequency.toFixed(1)}Hz (${harmonicsNoSync} harmonics), sync=${dominantSync?.frequency.toFixed(1)}Hz (${harmonicsSync} harmonics)`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, slaveWaveform, duration },
        noSync: {
          dominantFrequency: dominantNoSync?.frequency || 0,
          harmonicCount: harmonicsNoSync,
          rms: calculateRMS(samplesNoSync),
          peak: calculatePeak(samplesNoSync)
        },
        withSync: {
          dominantFrequency: dominantSync?.frequency || 0,
          harmonicCount: harmonicsSync,
          rms: calculateRMS(samplesSync),
          peak: calculatePeak(samplesSync)
        },
        // Cambios esperados con sync:
        // 1. La frecuencia fundamental cambia de slaveFreq a masterFreq
        // 2. Generalmente mÃ¡s armÃ³nicos (timbre mÃ¡s rico)
        frequencyShift: (dominantSync?.frequency || 0) - (dominantNoSync?.frequency || 0),
        harmonicIncrease: harmonicsSync - harmonicsNoSync
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST DE MODULACIÃ“N CV 1V/OCTAVA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test de modulaciÃ³n de frecuencia por CV con estÃ¡ndar 1V/Octava.
     * 
     * Simula una seÃ±al de voltaje pasando por la matriz con un pin GREY
     * (precisiÃ³n Â±0.5%) hacia la entrada CV de frecuencia del oscilador.
     * 
     * El sistema Synthi 100 usa el estÃ¡ndar 1V/Octava:
     * - +1V de CV â†’ frecuencia Ã— 2 (1 octava arriba)
     * - -1V de CV â†’ frecuencia Ã· 2 (1 octava abajo)
     * 
     * Constantes del sistema (de voltageConstants.js):
     * - DIGITAL_TO_VOLTAGE = 4.0 (1.0 digital = 4V)
     * - VOLTS_PER_OCTAVE = 1.0
     * - Pin GREY = 100kÎ©, ganancia Ã—1
     * 
     * ConfiguraciÃ³n del oscilador (de oscillator.config.js):
     * - cvScale = 2
     * - octavesPerUnit = 0.5
     * - â†’ 1.0 digital = 1 octava
     * 
     * Para que 1V = 1 octava:
     * - 1V = 0.25 digital (1V / 4V)
     * - Necesitamos que el sistema amplifique Ã—4 para compensar
     * - Esto se logra ajustando cvScaleÃ—octavesPerUnit = 2 (en cents: Ã—4800)
     * 
     * En la implementaciÃ³n actual:
     * - cvScale=2, octavesPerUnit=0.5 â†’ centsGain = 1200
     * - 1.0 digital â†’ 1200 cents â†’ 1 octava
     * - Para 1V real (0.25 digital) â†’ necesitamos centsGain = 4800
     * 
     * Este test verifica el comportamiento con la calibraciÃ³n correcta para 1V/Oct.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.baseFrequency - Frecuencia base del oscilador (Hz)
     * @param {number} config.cvVoltage - Voltaje CV a aplicar (positivo o negativo)
     * @param {string} [config.waveform='sine'] - Forma de onda del oscilador
     * @param {string} [config.pinType='GREY'] - Tipo de pin (GREY para precisiÃ³n)
     * @param {boolean} [config.rangeLow=false] - true para rango LO (sub-audio)
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis con frecuencias medidas
     */
    window.testFrequencyCV = async function(config) {
      const {
        baseFrequency = 261,  // C4 (punto central del Synthi)
        cvVoltage = 1.0,      // +1V = +1 octava
        waveform = 'sine',
        pinType = 'GREY',     // Pin de precisiÃ³n
        rangeLow = false,     // HI por defecto
        duration = 0.5,
        sampleRate = 44100
      } = config;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CONSTANTES DEL SISTEMA (replicadas de voltageConstants.js)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const DIGITAL_TO_VOLTAGE = 4.0;  // 1.0 digital = 4V
      const VOLTS_PER_OCTAVE = 1.0;    // EstÃ¡ndar V/Oct
      
      // Resistencias de pines (Rf = 100kÎ© estÃ¡ndar)
      const PIN_GAINS = {
        WHITE: 1.0,    // 100kÎ© / 100kÎ© = 1
        GREY: 1.0,     // 100kÎ© / 100kÎ© = 1 (precisiÃ³n)
        GREEN: 1.47,   // 100kÎ© / 68kÎ© â‰ˆ 1.47
        RED: 37.04,    // 100kÎ© / 2.7kÎ© â‰ˆ 37
        BLUE: 10.0,    // 100kÎ© / 10kÎ© = 10
        YELLOW: 4.55,  // 100kÎ© / 22kÎ© â‰ˆ 4.55
        CYAN: 0.4,     // 100kÎ© / 250kÎ© = 0.4
        PURPLE: 0.1    // 100kÎ© / 1MÎ© = 0.1
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALIBRACIÃ“N PARA 1V/OCTAVA REAL
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // El estÃ¡ndar es: 1V de entrada â†’ 1 octava de cambio
      // 
      // ConversiÃ³n voltaje â†’ digital: cvVoltage / DIGITAL_TO_VOLTAGE
      // Ejemplo: 1V / 4V = 0.25 digital
      //
      // Para que 0.25 digital = 1 octava (1200 cents):
      // centsGain = 1200 / 0.25 = 4800 cents por unidad digital
      //
      // Con pin GREY (ganancia Ã—1):
      // centsGain = VOLTS_PER_OCTAVE Ã— DIGITAL_TO_VOLTAGE Ã— 1200 = 4800
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const pinGain = PIN_GAINS[pinType] || 1.0;
      
      // Ganancia total para el sistema CV del oscilador
      // Esta es la calibraciÃ³n correcta para 1V/Octava
      const centsPerVolt = 1200;  // 1 octava = 1200 cents
      const centsGain = centsPerVolt * DIGITAL_TO_VOLTAGE * pinGain;
      // Con GREY: 1200 Ã— 4 Ã— 1 = 4800 cents por unidad digital
      
      log(`CV Test: ${cvVoltage}V via ${pinType} pin (gain=${pinGain}Ã—) to ${waveform}@${baseFrequency}Hz`);
      log(`  centsGain=${centsGain}, expected shift=${cvVoltage * centsPerVolt} cents`);

      const length = Math.ceil(sampleRate * duration);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR SIN CV (frecuencia base)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineBase = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineBase.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscBase = new AudioWorkletNode(offlineBase, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscBase.parameters.get('frequency').value = baseFrequency;
      oscBase.parameters.get('gain').value = 1.0;
      oscBase.parameters.get('detune').value = 0;  // Sin CV
      oscBase.connect(offlineBase.destination);
      
      const bufferBase = await offlineBase.startRendering();
      const samplesBase = bufferBase.getChannelData(0);
      const spectrumBase = computeSpectrum(samplesBase, sampleRate);
      const dominantBase = findDominantFrequency(spectrumBase);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR CON CV (frecuencia modulada)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineCV = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineCV.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscCV = new AudioWorkletNode(offlineCV, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscCV.parameters.get('frequency').value = baseFrequency;
      oscCV.parameters.get('gain').value = 1.0;
      
      // Aplicar CV: convertir voltios â†’ digital â†’ cents
      // 1V â†’ 0.25 digital â†’ 0.25 Ã— 4800 = 1200 cents = 1 octava
      const cvDigital = cvVoltage / DIGITAL_TO_VOLTAGE;  // Voltios a digital
      const cvCents = cvDigital * centsGain;             // Digital a cents
      oscCV.parameters.get('detune').value = cvCents;
      
      log(`  cvDigital=${cvDigital.toFixed(4)}, cvCents=${cvCents.toFixed(1)}`);
      
      oscCV.connect(offlineCV.destination);
      
      const bufferCV = await offlineCV.startRendering();
      const samplesCV = bufferCV.getChannelData(0);
      const spectrumCV = computeSpectrum(samplesCV, sampleRate);
      const dominantCV = findDominantFrequency(spectrumCV);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALCULAR RESULTADOS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const measuredBaseFreq = dominantBase?.frequency || 0;
      const measuredCVFreq = dominantCV?.frequency || 0;
      
      // Calcular ratio de frecuencias (deberÃ­a ser 2 para +1V, 0.5 para -1V)
      const frequencyRatio = measuredCVFreq / measuredBaseFreq;
      
      // Calcular octavas de cambio: log2(ratio)
      const octavesChange = Math.log2(frequencyRatio);
      
      // Frecuencia esperada segÃºn 1V/Oct
      const expectedFreq = baseFrequency * Math.pow(2, cvVoltage / VOLTS_PER_OCTAVE);
      
      log(`  Result: base=${measuredBaseFreq.toFixed(1)}Hz, withCV=${measuredCVFreq.toFixed(1)}Hz`, 'success');
      log(`  Ratio=${frequencyRatio.toFixed(4)}, octaves=${octavesChange.toFixed(4)}, expected=${expectedFreq.toFixed(1)}Hz`);

      return {
        config: { baseFrequency, cvVoltage, waveform, pinType, rangeLow },
        calibration: {
          pinGain,
          centsGain,
          cvDigital,
          cvCents
        },
        baseFrequency: {
          requested: baseFrequency,
          measured: measuredBaseFreq,
          rms: calculateRMS(samplesBase),
          peak: calculatePeak(samplesBase)
        },
        withCV: {
          expected: expectedFreq,
          measured: measuredCVFreq,
          rms: calculateRMS(samplesCV),
          peak: calculatePeak(samplesCV)
        },
        analysis: {
          frequencyRatio,
          octavesChange,
          expectedOctaves: cvVoltage / VOLTS_PER_OCTAVE,
          error: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)),
          errorCents: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)) * 1200
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST: CV THERMAL SLEW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Testea el efecto de slew tÃ©rmico en seÃ±ales CV.
     * 
     * Emula la inercia tÃ©rmica del transistor en VCOs del Synthi 100:
     * - Calentamiento rÃ¡pido (subida): Ï„ â‰ˆ 150ms
     * - Enfriamiento lento (bajada): Ï„ â‰ˆ 500ms
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.cvStep - Magnitud del salto CV (en unidades digitales)
     * @param {string} config.direction - 'up' o 'down'
     * @param {number} [config.threshold=0.5] - Umbral de activaciÃ³n
     * @param {number} [config.riseTimeConstant=0.15] - Constante de tiempo subida (s)
     * @param {number} [config.fallTimeConstant=0.5] - Constante de tiempo bajada (s)
     * @param {number} [config.duration=1.0] - DuraciÃ³n del test en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis de slew
     */
    window.testThermalSlew = async function(config) {
      const {
        cvStep = 2.0,
        direction = 'up',
        threshold = 0.5,
        riseTimeConstant = 0.15,
        fallTimeConstant = 0.5,
        duration = 1.0,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const stepSample = Math.floor(sampleRate * 0.1);  // Salto a los 100ms

      log(`Thermal Slew Test: step=${cvStep}, direction=${direction}, threshold=${threshold}`);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR CONTEXTO Y CARGAR WORKLET
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR FUENTE CV CON SALTO INSTANTÃNEO
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const cvSource = offline.createConstantSource();
      if (direction === 'up') {
        cvSource.offset.setValueAtTime(0, 0);
        cvSource.offset.setValueAtTime(cvStep, stepSample / sampleRate);
      } else {
        cvSource.offset.setValueAtTime(cvStep, 0);
        cvSource.offset.setValueAtTime(0, stepSample / sampleRate);
      }
      cvSource.start();

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR PROCESADOR THERMAL SLEW
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const thermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
        processorOptions: {
          riseTimeConstant,
          fallTimeConstant
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      thermalSlew.parameters.get('threshold').value = threshold;
      thermalSlew.parameters.get('enabled').value = 1;

      // Conectar: source â†’ thermal slew â†’ destination
      cvSource.connect(thermalSlew);
      thermalSlew.connect(offline.destination);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR Y ANALIZAR
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Encontrar tiempo de respuesta: tiempo para alcanzar 63% del target
      const startIdx = stepSample;
      const targetValue = direction === 'up' ? cvStep : 0;
      const startValue = direction === 'up' ? 0 : cvStep;
      const deltaNeeded = Math.abs(targetValue - startValue) * 0.632;  // 63.2% (1 - e^-1)
      
      let settlingIdx = length - 1;
      for (let i = startIdx; i < samples.length; i++) {
        const progress = Math.abs(samples[i] - startValue);
        if (progress >= deltaNeeded) {
          settlingIdx = i;
          break;
        }
      }
      const settlingTime = (settlingIdx - startIdx) / sampleRate;

      // Medir valor final
      const finalValue = samples[samples.length - 1];
      
      // Medir si el slew se activÃ³ (valor intermedio entre start y target durante transiciÃ³n)
      const midIdx = startIdx + Math.floor((settlingIdx - startIdx) / 2);
      const midValue = samples[midIdx];
      const midExpected = startValue + (targetValue - startValue) * 0.5;
      const slewActive = Math.abs(midValue - targetValue) > 0.01;

      // Calcular asimetrÃ­a (ratio de tiempos de respuesta)
      // Para esto necesitamos medir ambas direcciones si es posible
      const expectedTimeConstant = direction === 'up' ? riseTimeConstant : fallTimeConstant;

      log(`  Settling time: ${(settlingTime * 1000).toFixed(1)}ms (expected ~${(expectedTimeConstant * 1000).toFixed(0)}ms)`);
      log(`  Final value: ${finalValue.toFixed(4)} (target: ${targetValue})`);

      return {
        config: {
          cvStep,
          direction,
          threshold,
          riseTimeConstant,
          fallTimeConstant
        },
        analysis: {
          settlingTime,
          settlingTimeMs: settlingTime * 1000,
          expectedTimeConstantMs: expectedTimeConstant * 1000,
          timeConstantRatio: settlingTime / expectedTimeConstant,
          slewActive,
          finalValue,
          targetValue,
          finalError: Math.abs(finalValue - targetValue)
        },
        samples: {
          beforeStep: samples[startIdx - 10],
          atStep: samples[startIdx + 1],
          midSlew: midValue,
          final: finalValue
        }
      };
    };

    /**
     * Test de bypass del thermal slew.
     */
    window.testThermalSlewBypass = async function(config) {
      const {
        cvStep = 2.0,
        duration = 0.2,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const stepSample = Math.floor(sampleRate * 0.05);

      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');

      const cvSource = offline.createConstantSource();
      cvSource.offset.setValueAtTime(0, 0);
      cvSource.offset.setValueAtTime(cvStep, stepSample / sampleRate);
      cvSource.start();

      const thermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      thermalSlew.parameters.get('enabled').value = 0;  // BYPASS

      cvSource.connect(thermalSlew);
      thermalSlew.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // En bypass, el salto debe ser instantÃ¡neo
      const valueBeforeStep = samples[stepSample - 1];
      const valueAfterStep = samples[stepSample + 10];

      return {
        bypass: true,
        valueBeforeStep,
        valueAfterStep,
        expectedBeforeStep: 0,
        expectedAfterStep: cvStep,
        instantaneous: Math.abs(valueAfterStep - cvStep) < 0.01
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST: HYBRID CLIPPING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Genera la curva de clipping hÃ­brido (replica de voltageConstants.js).
     * Tres zonas: lineal â†’ soft (tanh) â†’ hard clip
     */
    function createHybridClipCurve(
      samples = 1024,
      linearThreshold = 2.25,
      softThreshold = 2.875,
      hardLimit = 3.0,
      softness = 2.0
    ) {
      const curve = new Float32Array(samples);
      const softZoneWidth = hardLimit - linearThreshold;
      
      for (let i = 0; i < samples; i++) {
        const t = i / (samples - 1);
        const normalizedIndex = 2 * t - 1;
        const x = normalizedIndex * hardLimit;
        
        const absX = Math.abs(x);
        const sign = x >= 0 ? 1 : -1;
        
        let y;
        
        if (absX <= linearThreshold) {
          y = x;
        } else if (absX < hardLimit) {
          const excess = absX - linearThreshold;
          const normalizedExcess = excess / softZoneWidth;
          const compressedNormalized = Math.tanh(softness * normalizedExcess);
          let compressedExcess = compressedNormalized * softZoneWidth;
          compressedExcess = Math.min(compressedExcess, excess);
          
          const interpFrac = 0.05;
          if (normalizedExcess < interpFrac) {
            const alpha = normalizedExcess / interpFrac;
            const ySoft = linearThreshold + compressedExcess;
            const yLinear = absX;
            y = sign * (yLinear * (1 - alpha) + ySoft * alpha);
          } else {
            y = sign * (linearThreshold + compressedExcess);
          }
        } else {
          y = sign * hardLimit;
        }
        
        curve[i] = y;
      }
      
      return curve;
    }

    /**
     * Testea el comportamiento del clipping hÃ­brido con seÃ±ales de audio.
     * 
     * Verifica las tres zonas de la curva de saturaciÃ³n:
     * - Zona lineal: |V| < 9V (2.25 digital) â†’ THD muy bajo
     * - Zona soft: 9V < |V| < 11.5V â†’ THD moderado (tanh suave)
     * - Zona hard: |V| > 12V (3.0 digital) â†’ THD alto (clipping duro)
     * 
     * NOTA: El WaveShaperNode opera en rango [-1, +1], asÃ­ que normalizamos
     * la entrada dividiÃ©ndola por hardLimit y luego multiplicamos la salida.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.amplitude - Amplitud de entrada (en unidades digitales)
     * @param {number} [config.frequency=440] - Frecuencia del tono de prueba
     * @param {number} [config.linearThreshold=2.25] - Umbral zona lineal
     * @param {number} [config.softThreshold=2.875] - Umbral zona soft
     * @param {number} [config.hardLimit=3.0] - LÃ­mite duro (raÃ­les Â±12V)
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} AnÃ¡lisis de THD y forma de onda
     */
    window.testHybridClipping = async function(config) {
      const {
        amplitude = 1.0,
        frequency = 440,
        linearThreshold = 2.25,
        softThreshold = 2.875,
        hardLimit = 3.0,
        softness = 2.0,
        duration = 0.5,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);

      log(`Hybrid Clip Test: amplitude=${amplitude}, freq=${frequency}Hz`);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR CONTEXTO Y WAVESHAPER
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Crear oscilador limpio
      const osc = offline.createOscillator();
      osc.frequency.value = frequency;
      osc.type = 'sine';

      // El WaveShaperNode opera en [-1, +1]
      // Nuestra curva estÃ¡ definida para entrada/salida en [-hardLimit, +hardLimit]
      // AsÃ­ que normalizamos: entrada_ws = entrada_real / hardLimit
      //                       salida_real = salida_ws * hardLimit
      
      // Pre-gain: escala la amplitud al rango de entrada del WaveShaper
      // Si amplitude=3.0 y hardLimit=3.0, preGain=1.0 (entrada llega a Â±1)
      // Si amplitude=1.0 y hardLimit=3.0, preGain=0.333 (entrada llega a Â±0.333)
      const preGain = offline.createGain();
      preGain.gain.value = amplitude / hardLimit;

      // Crear WaveShaper con curva hÃ­brida
      // La curva mapea [-1,+1] â†’ curva normalizada
      const shaper = offline.createWaveShaper();
      shaper.curve = createHybridClipCurve(1024, linearThreshold, softThreshold, hardLimit, softness);
      shaper.oversample = '2x';

      // Post-gain: NO lo aplicamos para la mediciÃ³n
      // Queremos medir el output del shaper directamente para comparar con hardLimit
      
      // Conectar cadena directa (sin post-gain para mediciÃ³n correcta)
      osc.connect(preGain);
      preGain.connect(shaper);
      shaper.connect(offline.destination);
      osc.start();

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ANÃLISIS: THD y caracterÃ­sticas
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const thd = measureTHD(spectrum, frequency, 10);

      // Medir pico de salida (del WaveShaper, ya en escala hardLimit)
      const outputPeak = calculatePeak(samples);
      const inputPeak = amplitude;

      // Determinar zona de operaciÃ³n basada en la amplitud de entrada
      let zone;
      if (amplitude <= linearThreshold) {
        zone = 'linear';
      } else if (amplitude <= hardLimit) {
        zone = 'soft';
      } else {
        zone = 'hard';
      }

      // Calcular compresiÃ³n (ratio entrada/salida en pico)
      const compressionRatio = outputPeak > 0 ? inputPeak / outputPeak : 1;
      
      // Determinar si estÃ¡ clippeando (output cerca del hardLimit)
      const isClipping = outputPeak >= hardLimit * 0.95;

      log(`  Zone: ${zone}, THD: ${thd?.toFixed(2)}%, Peak out: ${outputPeak.toFixed(3)}`);

      return {
        config: {
          amplitude,
          frequency,
          linearThreshold,
          softThreshold,
          hardLimit,
          softness
        },
        analysis: {
          zone,
          thd,
          thdPercent: thd,
          dominantFrequency: dominant?.frequency || 0,
          inputPeak,
          outputPeak,
          compressionRatio,
          isCompressing: compressionRatio > 1.05,
          isClipping
        }
      };
    };

    /**
     * Test de simetrÃ­a del clipping hÃ­brido.
     * Verifica que la distorsiÃ³n es igual para seÃ±ales positivas y negativas.
     */
    window.testHybridClipSymmetry = async function(config) {
      const {
        amplitude = 2.5,
        hardLimit = 3.0,
        duration = 0.1,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Crear rampa lineal de -1 a +1 (normalizada)
      const bufferSource = offline.createBufferSource();
      const rampBuffer = offline.createBuffer(1, length, sampleRate);
      const rampData = rampBuffer.getChannelData(0);
      
      // La rampa va de -amplitude/hardLimit a +amplitude/hardLimit
      // para que la entrada al WaveShaper estÃ© correctamente escalada
      const normalizedAmplitude = amplitude / hardLimit;
      for (let i = 0; i < length; i++) {
        rampData[i] = ((i / (length - 1)) * 2 - 1) * normalizedAmplitude;
      }
      bufferSource.buffer = rampBuffer;

      const shaper = offline.createWaveShaper();
      shaper.curve = createHybridClipCurve(1024);
      shaper.oversample = '2x';

      // Conectar directamente (sin gains)
      bufferSource.connect(shaper);
      shaper.connect(offline.destination);
      bufferSource.start();

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Comparar valores positivos vs negativos (deberÃ­an ser simÃ©tricos)
      const midIdx = Math.floor(length / 2);
      let maxAsymmetry = 0;
      for (let i = 0; i < midIdx; i++) {
        const negVal = samples[i];
        const posVal = samples[length - 1 - i];
        const asymmetry = Math.abs(Math.abs(negVal) - Math.abs(posVal));
        if (asymmetry > maxAsymmetry) maxAsymmetry = asymmetry;
      }

      return {
        amplitude,
        maxAsymmetry,
        isSymmetric: maxAsymmetry < 0.05,  // Tolerancia mÃ¡s amplia
        samples: {
          negPeak: Math.min(...samples),
          posPeak: Math.max(...samples)
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TESTS DE INTEGRACIÃ“N: AUDIOWORKLET â†’ AUDIOPARAM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 
    // Estos tests verifican que la seÃ±al de un AudioWorklet llega correctamente
    // a un AudioParam, detectando el bug donde condicionales en el worklet
    // bloquean la propagaciÃ³n de seÃ±al.
    //
    // BUG HISTÃ“RICO (Enero 2026):
    // - AudioWorklets con if/else, ternarios, Math.max/min en process()
    //   producÃ­an seÃ±al correcta hacia nodos de audio normales
    //   pero BLOQUEABAN la seÃ±al hacia AudioParams
    // - Solo aritmÃ©tica pura funcionaba hacia AudioParams
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test crÃ­tico: Verifica que un AudioWorklet puede modular un AudioParam.
     * 
     * Este es el test mÃ¡s importante para detectar el bug de condicionales.
     * Conecta: cvSource â†’ AudioWorklet â†’ GainNode.gain â†’ destination
     * 
     * Si el worklet tiene condicionales problemÃ¡ticos, la seÃ±al no llegarÃ¡
     * al gain y el output serÃ¡ silencio.
     */
    window.testWorkletToAudioParam = async function(config) {
      const {
        workletPath = '/src/assets/js/worklets/cvSoftClip.worklet.js',
        workletName = 'cv-soft-clip',
        processorOptions = {},
        cvValue = 0.5,           // Valor CV de entrada
        duration = 0.2,
        sampleRate = 44100
      } = config;

      log(`Workletâ†’AudioParam Test: ${workletName} with CV=${cvValue}`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Cargar el worklet
      await offline.audioWorklet.addModule(workletPath);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Crear cadena: CV constante â†’ Worklet â†’ GainNode.gain â†’ OscillatorNode
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // 1. Fuente CV constante
      const cvSource = offline.createConstantSource();
      cvSource.offset.value = cvValue;
      
      // 2. AudioWorklet bajo test
      const worklet = new AudioWorkletNode(offline, workletName, {
        processorOptions,
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      // 3. GainNode cuya ganancia serÃ¡ modulada por el worklet
      const modulatedGain = offline.createGain();
      modulatedGain.gain.value = 0;  // Base 0, el worklet debe aportar la ganancia

      // 4. SeÃ±al de prueba (sine constante a 1.0 de amplitud)
      const testOsc = offline.createOscillator();
      testOsc.frequency.value = 440;
      testOsc.type = 'sine';

      // Conectar: cvSource â†’ worklet â†’ gain.gain (AudioParam!)
      cvSource.connect(worklet);
      worklet.connect(modulatedGain.gain);  // â† CONEXIÃ“N CRÃTICA A AudioParam

      // Conectar: testOsc â†’ modulatedGain â†’ destination
      testOsc.connect(modulatedGain);
      modulatedGain.connect(offline.destination);

      cvSource.start();
      testOsc.start();

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Renderizar y analizar
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Calcular RMS y peak del output
      let sumSq = 0;
      let peak = 0;
      for (let i = 0; i < samples.length; i++) {
        sumSq += samples[i] * samples[i];
        const abs = Math.abs(samples[i]);
        if (abs > peak) peak = abs;
      }
      const rms = Math.sqrt(sumSq / samples.length);

      // El output deberÃ­a tener seÃ±al si el worklet pasÃ³ la seÃ±al al gain
      // Si el worklet bloqueÃ³ la seÃ±al, gain.gain = 0 y output es silencio
      const hasSignal = rms > 0.001;
      const signalLevel = peak;

      // Calcular quÃ© porcentaje del CV llegÃ³ al gain
      // Si cvValue = 0.5 y el worklet es transparente, gain â‰ˆ 0.5
      // y el output del sine (peak 1.0) * 0.5 â‰ˆ 0.5
      const expectedPeak = Math.abs(cvValue);  // Aproximado, asumiendo worklet ~transparente
      const cvPassthrough = signalLevel > 0 ? signalLevel / expectedPeak : 0;

      log(`  Output RMS: ${rms.toFixed(4)}, Peak: ${peak.toFixed(4)}`);
      log(`  Signal detected: ${hasSignal ? 'YES âœ“' : 'NO âœ—'}`);
      log(`  CV passthrough: ${(cvPassthrough * 100).toFixed(1)}%`);

      return {
        config: { workletName, cvValue },
        result: {
          hasSignal,
          rms,
          peak,
          cvPassthrough,
          // El test PASA si hay seÃ±al significativa
          passed: hasSignal && rms > 0.01
        }
      };
    };

    /**
     * Test de cadena CV completa para FM.
     * 
     * Emula la cadena real de modulaciÃ³n de frecuencia:
     * cvSource â†’ cvThermalSlew â†’ cvSoftClip â†’ centsGain â†’ oscillator.detune
     * 
     * Verifica que todos los eslabones pasan seÃ±al correctamente.
     */
    window.testCompleteFMChain = async function(config) {
      const {
        baseFrequency = 440,
        cvVoltage = 1.0,           // Voltios de CV
        duration = 0.5,
        sampleRate = 44100,
        includeThermalSlew = true,
        includeSoftClip = true
      } = config;

      const DIGITAL_TO_VOLTAGE = 4.0;
      const centsGain = 4800;  // 1V/octava calibrado
      const cvDigital = cvVoltage / DIGITAL_TO_VOLTAGE;  // 1V â†’ 0.25 digital
      const expectedCents = cvDigital * centsGain;       // 0.25 Ã— 4800 = 1200 cents
      const expectedFreq = baseFrequency * Math.pow(2, cvVoltage);  // +1V = +1 octava

      log(`Complete FM Chain Test: ${cvVoltage}V â†’ ${expectedCents} cents`);
      log(`  Expected: ${baseFrequency}Hz â†’ ${expectedFreq.toFixed(1)}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Cargar worklets necesarios
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      if (includeThermalSlew) {
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');
      }
      if (includeSoftClip) {
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvSoftClip.worklet.js');
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Construir cadena CV
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // 1. Fuente CV
      const cvSource = offline.createConstantSource();
      cvSource.offset.value = cvDigital;

      // 2. Nodo de entrada a la cadena (para medir)
      const cvChainInput = offline.createGain();
      cvChainInput.gain.value = 1.0;

      // 3. Thermal Slew (opcional)
      let cvThermalSlew = null;
      if (includeThermalSlew) {
        cvThermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
          processorOptions: { riseTimeConstant: 0.001, fallTimeConstant: 0.001 },  // RÃ¡pido para test
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        cvThermalSlew.parameters.get('enabled').value = 1;
        cvThermalSlew.parameters.get('threshold').value = 10;  // Alto para que no se active
      }

      // 4. Soft Clip (opcional)
      let cvSoftClip = null;
      if (includeSoftClip) {
        cvSoftClip = new AudioWorkletNode(offline, 'cv-soft-clip', {
          processorOptions: { coefficient: 0.0001 },  // Muy suave
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
      }

      // 5. Ganancia de cents (multiplica por 4800)
      const freqCVInput = offline.createGain();
      freqCVInput.gain.value = centsGain;

      // 6. Oscilador de prueba
      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine', sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      osc.parameters.get('frequency').value = baseFrequency;
      osc.parameters.get('gain').value = 1.0;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Conectar cadena
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      cvSource.connect(cvChainInput);

      let lastNode = cvChainInput;
      if (cvThermalSlew) {
        lastNode.connect(cvThermalSlew);
        lastNode = cvThermalSlew;
      }
      if (cvSoftClip) {
        lastNode.connect(cvSoftClip);
        lastNode = cvSoftClip;
      }
      lastNode.connect(freqCVInput);
      
      // CONEXIÃ“N CRÃTICA: freqCVInput â†’ detune AudioParam
      freqCVInput.connect(osc.parameters.get('detune'));

      osc.connect(offline.destination);

      cvSource.start();

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Renderizar y medir frecuencia
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Medir frecuencia dominante
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const measuredFreq = dominant?.frequency || 0;

      // Calcular error
      const freqError = Math.abs(measuredFreq - expectedFreq);
      const freqErrorCents = 1200 * Math.log2(measuredFreq / expectedFreq);
      const withinTolerance = Math.abs(freqErrorCents) < 50;  // Â±50 cents

      log(`  Measured: ${measuredFreq.toFixed(1)}Hz`);
      log(`  Error: ${freqErrorCents.toFixed(1)} cents`);
      log(`  Status: ${withinTolerance ? 'PASS âœ“' : 'FAIL âœ—'}`);

      return {
        config: { baseFrequency, cvVoltage, includeThermalSlew, includeSoftClip },
        expected: { frequency: expectedFreq, cents: expectedCents },
        measured: { frequency: measuredFreq },
        analysis: {
          freqError,
          freqErrorCents,
          withinTolerance,
          passed: withinTolerance && measuredFreq > 0
        }
      };
    };

    /**
     * Test A/B: Compara cadena con y sin worklet para detectar bloqueo de seÃ±al.
     * 
     * Si el worklet tiene cÃ³digo problemÃ¡tico, la versiÃ³n CON worklet
     * tendrÃ¡ seÃ±al significativamente menor que SIN worklet.
     */
    window.testWorkletSignalPassthrough = async function(config) {
      const {
        workletPath = '/src/assets/js/worklets/cvSoftClip.worklet.js',
        workletName = 'cv-soft-clip',
        processorOptions = {},
        cvValue = 0.5,
        duration = 0.2,
        sampleRate = 44100
      } = config;

      log(`Signal Passthrough Test: ${workletName}`);

      const length = Math.ceil(sampleRate * duration);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Test A: SIN worklet (baseline)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineA = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      const cvSourceA = offlineA.createConstantSource();
      cvSourceA.offset.value = cvValue;

      const gainA = offlineA.createGain();
      gainA.gain.value = 0;

      const oscA = offlineA.createOscillator();
      oscA.frequency.value = 440;

      // Directo: cvSource â†’ gain.gain
      cvSourceA.connect(gainA.gain);
      oscA.connect(gainA);
      gainA.connect(offlineA.destination);

      cvSourceA.start();
      oscA.start();

      const bufferA = await offlineA.startRendering();
      const samplesA = bufferA.getChannelData(0);
      const peakA = Math.max(...samplesA.map(Math.abs));

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Test B: CON worklet
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineB = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineB.audioWorklet.addModule(workletPath);

      const cvSourceB = offlineB.createConstantSource();
      cvSourceB.offset.value = cvValue;

      const worklet = new AudioWorkletNode(offlineB, workletName, {
        processorOptions,
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });

      const gainB = offlineB.createGain();
      gainB.gain.value = 0;

      const oscB = offlineB.createOscillator();
      oscB.frequency.value = 440;

      // Con worklet: cvSource â†’ worklet â†’ gain.gain
      cvSourceB.connect(worklet);
      worklet.connect(gainB.gain);
      oscB.connect(gainB);
      gainB.connect(offlineB.destination);

      cvSourceB.start();
      oscB.start();

      const bufferB = await offlineB.startRendering();
      const samplesB = bufferB.getChannelData(0);
      const peakB = Math.max(...samplesB.map(Math.abs));

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Comparar resultados
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const ratio = peakA > 0 ? peakB / peakA : 0;
      const signalBlocked = ratio < 0.5;  // Si el worklet bloquea >50% de seÃ±al
      const workletTransparent = ratio > 0.9;  // Si pasa >90% de seÃ±al

      log(`  Without worklet: peak=${peakA.toFixed(4)}`);
      log(`  With worklet: peak=${peakB.toFixed(4)}`);
      log(`  Signal ratio: ${(ratio * 100).toFixed(1)}%`);
      log(`  Status: ${signalBlocked ? 'BLOCKED âœ—' : 'PASS âœ“'}`);

      return {
        config: { workletName, cvValue },
        withoutWorklet: { peak: peakA },
        withWorklet: { peak: peakB },
        analysis: {
          signalRatio: ratio,
          signalBlocked,
          workletTransparent,
          // El test FALLA si el worklet bloquea la seÃ±al
          passed: !signalBlocked && peakB > 0.01
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST: FM Octave Accuracy (diagnÃ³stico de pÃ©rdida de seÃ±al CV)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test de precisiÃ³n de octava para modulaciÃ³n FM vÃ­a matriz de control.
     * 
     * Reproduce el escenario:
     *   Osc modulante (cuadrada) â†’ [pinFilter] â†’ [pinGain] â†’ cvChainInput
     *   â†’ [cvThermalSlew] â†’ [cvSoftClip] â†’ freqCVInput(Ã—4800) â†’ detune del portador
     * 
     * Mide la frecuencia del portador en las fases positiva y negativa
     * del modulante y calcula el ratio real vs esperado.
     * 
     * @param {Object} config
     * @param {number} config.carrierFreq - Frecuencia portador (Hz)
     * @param {number} config.modulatorVpp - Voltaje pico-a-pico del modulante (V)
     * @param {number} [config.modulatorFreq=1] - Frecuencia modulante (Hz)
     * @param {boolean} [config.includePinFilter=true] - Incluir filtro RC del pin
     * @param {boolean} [config.includeThermalSlew=true] - Incluir thermal slew
     * @param {boolean} [config.includeSoftClip=true] - Incluir soft clip
     * @param {string} [config.pinType='GREY'] - Tipo de pin
     */
    window.testFMOctaveAccuracy = async function(config) {
      const {
        carrierFreq = 400,
        modulatorVpp = 1.0,         // 1V p-p â†’ se espera 1 octava
        modulatorFreq = 1,          // 1 Hz (LFO lento)
        includePinFilter = true,
        includeThermalSlew = true,
        includeSoftClip = true,
        pinType = 'GREY',
        sampleRate = 44100,
        duration = 2.0              // 2s â†’ 2 ciclos completos del modulante
      } = config;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CONSTANTES DEL SISTEMA (replicadas de voltageConstants.js)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const DIGITAL_TO_VOLTAGE = 4.0;
      const CENTS_PER_OCTAVE = 1200;
      const centsGain = CENTS_PER_OCTAVE * DIGITAL_TO_VOLTAGE; // 4800
      
      // ConversiÃ³n: Vpp â†’ amplitud digital del modulante
      const peakVoltage = modulatorVpp / 2;              // Â±peakVoltage
      const peakDigital = peakVoltage / DIGITAL_TO_VOLTAGE; // Â±peakDigital
      
      // Frecuencias esperadas del portador
      const expectedCentsHigh = peakDigital * centsGain;    // cents en fase positiva
      const expectedCentsLow = -peakDigital * centsGain;    // cents en fase negativa
      const expectedFreqHigh = carrierFreq * Math.pow(2, expectedCentsHigh / 1200);
      const expectedFreqLow = carrierFreq * Math.pow(2, expectedCentsLow / 1200);
      const expectedRatio = expectedFreqHigh / expectedFreqLow;
      const expectedOctaves = Math.log2(expectedRatio);
      
      // ConfiguraciÃ³n del pin
      const PIN_CUTOFFS = { WHITE: 15915, GREY: 15915, GREEN: 23405, RED: 24000 };
      const PIN_GAINS = { WHITE: 1.0, GREY: 1.0, GREEN: 1.47, RED: 37.04 };
      const pinCutoff = PIN_CUTOFFS[pinType] || 15915;
      const pinGainValue = PIN_GAINS[pinType] || 1.0;

      log(`FM Octave Test: ${modulatorVpp}Vpp @ ${carrierFreq}Hz carrier`);
      log(`  Peak: Â±${peakVoltage}V = Â±${peakDigital.toFixed(4)} digital`);
      log(`  Expected: ${expectedFreqLow.toFixed(1)}Hz â€“ ${expectedFreqHigh.toFixed(1)}Hz`);
      log(`  Expected ratio: ${expectedRatio.toFixed(4)} (${expectedOctaves.toFixed(4)} octaves)`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({ numberOfChannels: 2, length, sampleRate });

      // Cargar worklets
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      if (includeThermalSlew) {
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');
      }
      if (includeSoftClip) {
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvSoftClip.worklet.js');
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // MODULANTE: Oscilador cuadrada a frecuencia LFO
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const modulator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'pulse',
          moduleSlewEnabled: true,     // Como en la app real
          moduleSlewCutoff: 20000
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      modulator.parameters.get('frequency').value = modulatorFreq;
      modulator.parameters.get('gain').value = peakDigital;  // Amplitud = peak digital
      modulator.parameters.get('pulseWidth').value = 0.5;
      modulator.parameters.get('detune').value = 0;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CADENA CV COMPLETA (replica app.js _handlePanel6ControlToggle)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // 1. Pin Filter (BiquadFilter lowpass, emula RC del pin)
      let pinFilter = null;
      if (includePinFilter) {
        pinFilter = offline.createBiquadFilter();
        pinFilter.type = 'lowpass';
        pinFilter.Q.value = 0.5;
        pinFilter.frequency.value = Math.min(pinCutoff, 24000);
      }

      // 2. Pin Gain (Rf / R_pin)
      const pinGain = offline.createGain();
      pinGain.gain.value = pinGainValue;

      // 3. CV Chain Input (unity gain, punto de conexiÃ³n)
      const cvChainInput = offline.createGain();
      cvChainInput.gain.value = 1.0;

      // 4. Thermal Slew (opcional)
      let cvThermalSlew = null;
      if (includeThermalSlew) {
        cvThermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
          processorOptions: { riseTimeConstant: 0.005, fallTimeConstant: 0.02 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        cvThermalSlew.parameters.get('enabled').value = 1;
        cvThermalSlew.parameters.get('threshold').value = 0.5;
      }

      // 5. Soft Clip (opcional)
      let cvSoftClip = null;
      if (includeSoftClip) {
        cvSoftClip = new AudioWorkletNode(offline, 'cv-soft-clip', {
          processorOptions: { coefficient: 0.0001 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
      }

      // 6. Freq CV Input (conversiÃ³n a cents: Ã—4800)
      const freqCVInput = offline.createGain();
      freqCVInput.gain.value = centsGain;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PORTADOR: Oscilador a frecuencia base
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const carrier = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'sine',
          sinePurity: 1.0,
          sineShapeAttenuation: 0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      carrier.parameters.get('frequency').value = carrierFreq;
      carrier.parameters.get('gain').value = 1.0;
      carrier.parameters.get('detune').value = 0;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CONEXIONES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Cadena: modulator â†’ [pinFilter] â†’ pinGain â†’ cvChainInput
      //         â†’ [thermalSlew] â†’ [softClip] â†’ freqCVInput(Ã—4800) â†’ detune
      let lastModNode = modulator;
      if (pinFilter) {
        lastModNode.connect(pinFilter);
        lastModNode = pinFilter;
      }
      lastModNode.connect(pinGain);
      pinGain.connect(cvChainInput);

      let lastCVNode = cvChainInput;
      if (cvThermalSlew) {
        lastCVNode.connect(cvThermalSlew);
        lastCVNode = cvThermalSlew;
      }
      if (cvSoftClip) {
        lastCVNode.connect(cvSoftClip);
        lastCVNode = cvSoftClip;
      }
      lastCVNode.connect(freqCVInput);

      // ConexiÃ³n CRÃTICA: freqCVInput â†’ detune AudioParam del portador
      freqCVInput.connect(carrier.parameters.get('detune'));

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SALIDAS: Canal 0 = portador, Canal 1 = modulante (para referencia)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const merger = offline.createChannelMerger(2);
      carrier.connect(merger, 0, 0);
      modulator.connect(merger, 0, 1);
      merger.connect(offline.destination);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // RENDERIZAR
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const buffer = await offline.startRendering();
      const carrierSamples = buffer.getChannelData(0);
      const modulatorSamples = buffer.getChannelData(1);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ANÃLISIS: Separar segmentos HIGH y LOW del portador
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const samplesPerHalfCycle = Math.floor(sampleRate / modulatorFreq / 2);
      const margin = Math.floor(sampleRate * 0.05); // 50ms de margen en transiciones

      // Acumular muestras de las fases HIGH y LOW
      const highSegments = [];
      const lowSegments = [];
      const numCycles = Math.floor(duration * modulatorFreq);

      for (let cycle = 0; cycle < numCycles; cycle++) {
        const cycleStart = cycle * samplesPerHalfCycle * 2;
        // Primera mitad del ciclo: modulante en fase positiva
        const highStart = cycleStart + margin;
        const highEnd = cycleStart + samplesPerHalfCycle - margin;
        // Segunda mitad: modulante en fase negativa
        const lowStart = cycleStart + samplesPerHalfCycle + margin;
        const lowEnd = cycleStart + samplesPerHalfCycle * 2 - margin;

        if (highEnd <= carrierSamples.length && lowEnd <= carrierSamples.length) {
          highSegments.push(carrierSamples.slice(highStart, highEnd));
          lowSegments.push(carrierSamples.slice(lowStart, lowEnd));
        }
      }

      // Concatenar segmentos para anÃ¡lisis mÃ¡s robusto
      const allHigh = new Float32Array(highSegments.reduce((a, s) => a + s.length, 0));
      const allLow = new Float32Array(lowSegments.reduce((a, s) => a + s.length, 0));
      let offset = 0;
      for (const seg of highSegments) { allHigh.set(seg, offset); offset += seg.length; }
      offset = 0;
      for (const seg of lowSegments) { allLow.set(seg, offset); offset += seg.length; }

      // Medir frecuencia por zero-crossings (mÃ¡s preciso para seÃ±ales puras)
      function measureFreqByZeroCrossings(samples, sr) {
        const crossings = [];
        for (let i = 1; i < samples.length; i++) {
          if (samples[i - 1] < 0 && samples[i] >= 0) {
            // Interpolar cruce exacto
            const frac = -samples[i - 1] / (samples[i] - samples[i - 1]);
            crossings.push(i - 1 + frac);
          }
        }
        if (crossings.length < 2) return 0;
        // Calcular frecuencia promedio entre cruces consecutivos
        let totalPeriod = 0;
        for (let i = 1; i < crossings.length; i++) {
          totalPeriod += crossings[i] - crossings[i - 1];
        }
        const avgPeriod = totalPeriod / (crossings.length - 1);
        return sr / avgPeriod;
      }

      // TambiÃ©n medir por FFT para verificaciÃ³n cruzada
      const spectrumHigh = computeSpectrum(allHigh, sampleRate);
      const spectrumLow = computeSpectrum(allLow, sampleRate);
      const fftFreqHigh = findDominantFrequency(spectrumHigh)?.frequency || 0;
      const fftFreqLow = findDominantFrequency(spectrumLow)?.frequency || 0;

      const zcFreqHigh = measureFreqByZeroCrossings(allHigh, sampleRate);
      const zcFreqLow = measureFreqByZeroCrossings(allLow, sampleRate);

      // Usar zero-crossings como medida principal (mÃ¡s precisa)
      const measuredFreqHigh = zcFreqHigh || fftFreqHigh;
      const measuredFreqLow = zcFreqLow || fftFreqLow;
      const measuredRatio = measuredFreqHigh / measuredFreqLow;
      const measuredOctaves = Math.log2(measuredRatio);

      // Medir nivel real del modulante en las fases estables
      let modHighSum = 0, modHighCount = 0;
      let modLowSum = 0, modLowCount = 0;
      for (let cycle = 0; cycle < numCycles; cycle++) {
        const cycleStart = cycle * samplesPerHalfCycle * 2;
        const hS = cycleStart + margin;
        const hE = cycleStart + samplesPerHalfCycle - margin;
        const lS = cycleStart + samplesPerHalfCycle + margin;
        const lE = cycleStart + samplesPerHalfCycle * 2 - margin;
        if (hE <= modulatorSamples.length && lE <= modulatorSamples.length) {
          for (let i = hS; i < hE; i++) { modHighSum += modulatorSamples[i]; modHighCount++; }
          for (let i = lS; i < lE; i++) { modLowSum += modulatorSamples[i]; modLowCount++; }
        }
      }
      const avgModHigh = modHighSum / modHighCount;
      const avgModLow = modLowSum / modLowCount;
      const actualModVpp = (avgModHigh - avgModLow) * DIGITAL_TO_VOLTAGE;

      // Calcular error
      const octaveError = measuredOctaves - expectedOctaves;
      const errorCents = octaveError * 1200;
      const errorPercent = (measuredRatio / expectedRatio - 1) * 100;
      const voltageNeededForExactOctave = modulatorVpp / (measuredOctaves / expectedOctaves);

      log(`  Modulator digital level: high=${avgModHigh.toFixed(6)}, low=${avgModLow.toFixed(6)}`);
      log(`  Actual modulator Vpp: ${actualModVpp.toFixed(4)}V (requested: ${modulatorVpp}V)`);
      log(`  Carrier HIGH: ZC=${zcFreqHigh.toFixed(2)}Hz, FFT=${fftFreqHigh.toFixed(2)}Hz`);
      log(`  Carrier LOW:  ZC=${zcFreqLow.toFixed(2)}Hz, FFT=${fftFreqLow.toFixed(2)}Hz`);
      log(`  Ratio: ${measuredRatio.toFixed(6)} (expected ${expectedRatio.toFixed(6)})`);
      log(`  Octaves: ${measuredOctaves.toFixed(6)} (expected ${expectedOctaves.toFixed(6)})`);
      log(`  Error: ${errorCents.toFixed(2)} cents (${errorPercent.toFixed(3)}%)`);

      const passed = Math.abs(errorCents) < 10; // Tolerancia de 10 cents

      return {
        config: { carrierFreq, modulatorVpp, modulatorFreq, includePinFilter, includeThermalSlew, includeSoftClip, pinType },
        modulator: {
          requestedVpp: modulatorVpp,
          actualVpp: actualModVpp,
          digitalHigh: avgModHigh,
          digitalLow: avgModLow,
          levelLoss: (1 - actualModVpp / modulatorVpp) * 100  // % de pÃ©rdida
        },
        carrier: {
          freqHigh: { zeroCrossing: zcFreqHigh, fft: fftFreqHigh },
          freqLow: { zeroCrossing: zcFreqLow, fft: fftFreqLow }
        },
        expected: {
          freqHigh: expectedFreqHigh,
          freqLow: expectedFreqLow,
          ratio: expectedRatio,
          octaves: expectedOctaves
        },
        measured: {
          freqHigh: measuredFreqHigh,
          freqLow: measuredFreqLow,
          ratio: measuredRatio,
          octaves: measuredOctaves
        },
        error: {
          cents: errorCents,
          percent: errorPercent,
          octaveError,
          voltageNeededForExactOctave
        },
        analysis: {
          passed,
          tolerance: 'Â±10 cents'
        }
      };
    };

    /**
     * DiagnÃ³stico detallado: mide el nivel de seÃ±al en cada etapa de la cadena CV.
     * Identifica EXACTAMENTE dÃ³nde se pierde seÃ±al.
     */
    window.testCVChainStageByStage = async function(config) {
      const {
        cvAmplitude = 0.125,   // Â±0.125 digital = Â±0.5V = 1Vpp
        frequency = 1,          // 1 Hz cuadrada
        sampleRate = 44100,
        duration = 2.0
      } = config;

      const DIGITAL_TO_VOLTAGE = 4.0;
      const centsGain = 4800;
      const margin = Math.floor(sampleRate * 0.1);
      const samplesPerHalfCycle = Math.floor(sampleRate / frequency / 2);

      log(`CV Chain Stage-by-Stage: Â±${cvAmplitude} digital (Â±${(cvAmplitude * DIGITAL_TO_VOLTAGE).toFixed(2)}V)`);

      // Helper: medir nivel medio en la fase estable positiva
      async function measureStageOutput(setupFn) {
        const length = Math.ceil(sampleRate * duration);
        const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
        await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');
        await offline.audioWorklet.addModule('/src/assets/js/worklets/cvSoftClip.worklet.js');

        const outputNode = await setupFn(offline);
        outputNode.connect(offline.destination);

        const buffer = await offline.startRendering();
        const samples = buffer.getChannelData(0);

        // Medir nivel medio en las partes estables
        let highSum = 0, highCount = 0;
        let lowSum = 0, lowCount = 0;
        const numCycles = Math.floor(duration * frequency);
        for (let cycle = 0; cycle < numCycles; cycle++) {
          const cycleStart = cycle * samplesPerHalfCycle * 2;
          for (let i = cycleStart + margin; i < cycleStart + samplesPerHalfCycle - margin && i < samples.length; i++) {
            highSum += samples[i]; highCount++;
          }
          for (let i = cycleStart + samplesPerHalfCycle + margin; i < cycleStart + samplesPerHalfCycle * 2 - margin && i < samples.length; i++) {
            lowSum += samples[i]; lowCount++;
          }
        }
        return {
          avgHigh: highSum / highCount,
          avgLow: lowSum / lowCount,
          vpp: ((highSum / highCount) - (lowSum / lowCount)) * DIGITAL_TO_VOLTAGE
        };
      }

      const stages = {};

      // Etapa 0: Modulante solo (sin cadena)
      stages['0_modulator_raw'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        return mod;
      });

      // Etapa 1: + pinFilter
      stages['1_after_pinFilter'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 0.5;
        filter.frequency.value = 15915;
        mod.connect(filter);
        return filter;
      });

      // Etapa 2: + pinGain (GREY = 1.0)
      stages['2_after_pinGain'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.Q.value = 0.5; filter.frequency.value = 15915;
        const gain = ctx.createGain(); gain.gain.value = 1.0;
        mod.connect(filter); filter.connect(gain);
        return gain;
      });

      // Etapa 3: + cvChainInput
      stages['3_after_cvChainInput'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.Q.value = 0.5; filter.frequency.value = 15915;
        const pGain = ctx.createGain(); pGain.gain.value = 1.0;
        const cvIn = ctx.createGain(); cvIn.gain.value = 1.0;
        mod.connect(filter); filter.connect(pGain); pGain.connect(cvIn);
        return cvIn;
      });

      // Etapa 4: + cvThermalSlew
      stages['4_after_thermalSlew'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.Q.value = 0.5; filter.frequency.value = 15915;
        const pGain = ctx.createGain(); pGain.gain.value = 1.0;
        const cvIn = ctx.createGain(); cvIn.gain.value = 1.0;
        const slew = new AudioWorkletNode(ctx, 'cv-thermal-slew', {
          processorOptions: { riseTimeConstant: 0.005, fallTimeConstant: 0.02 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        slew.parameters.get('enabled').value = 1;
        slew.parameters.get('threshold').value = 0.5;
        mod.connect(filter); filter.connect(pGain); pGain.connect(cvIn); cvIn.connect(slew);
        return slew;
      });

      // Etapa 5: + cvSoftClip
      stages['5_after_softClip'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.Q.value = 0.5; filter.frequency.value = 15915;
        const pGain = ctx.createGain(); pGain.gain.value = 1.0;
        const cvIn = ctx.createGain(); cvIn.gain.value = 1.0;
        const slew = new AudioWorkletNode(ctx, 'cv-thermal-slew', {
          processorOptions: { riseTimeConstant: 0.005, fallTimeConstant: 0.02 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        slew.parameters.get('enabled').value = 1;
        slew.parameters.get('threshold').value = 0.5;
        const clip = new AudioWorkletNode(ctx, 'cv-soft-clip', {
          processorOptions: { coefficient: 0.0001 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.connect(filter); filter.connect(pGain); pGain.connect(cvIn);
        cvIn.connect(slew); slew.connect(clip);
        return clip;
      });

      // Etapa 6: + freqCVInput (Ã—4800) â€” mide el nivel en CENTS
      stages['6_after_freqCVInput'] = await measureStageOutput(async (ctx) => {
        const mod = new AudioWorkletNode(ctx, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: true, moduleSlewCutoff: 20000 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        mod.parameters.get('frequency').value = frequency;
        mod.parameters.get('gain').value = cvAmplitude;
        mod.parameters.get('pulseWidth').value = 0.5;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.Q.value = 0.5; filter.frequency.value = 15915;
        const pGain = ctx.createGain(); pGain.gain.value = 1.0;
        const cvIn = ctx.createGain(); cvIn.gain.value = 1.0;
        const slew = new AudioWorkletNode(ctx, 'cv-thermal-slew', {
          processorOptions: { riseTimeConstant: 0.005, fallTimeConstant: 0.02 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        slew.parameters.get('enabled').value = 1;
        slew.parameters.get('threshold').value = 0.5;
        const clip = new AudioWorkletNode(ctx, 'cv-soft-clip', {
          processorOptions: { coefficient: 0.0001 },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        const freqCV = ctx.createGain(); freqCV.gain.value = 4800;
        mod.connect(filter); filter.connect(pGain); pGain.connect(cvIn);
        cvIn.connect(slew); slew.connect(clip); clip.connect(freqCV);
        return freqCV;
      });

      // Calcular pÃ©rdidas por etapa
      const ref = stages['0_modulator_raw'].avgHigh;
      const report = {};
      for (const [name, data] of Object.entries(stages)) {
        const expectedHigh = name === '6_after_freqCVInput' ? ref * 4800 : ref;
        const loss = name === '6_after_freqCVInput'
          ? (1 - data.avgHigh / (ref * 4800)) * 100
          : (1 - data.avgHigh / ref) * 100;
        report[name] = {
          avgHigh: data.avgHigh,
          avgLow: data.avgLow,
          vpp: data.vpp,
          lossFromRef: loss
        };
        log(`  ${name}: high=${data.avgHigh.toFixed(8)}, low=${data.avgLow.toFixed(8)}, Vpp=${data.vpp.toFixed(6)}V, loss=${loss.toFixed(4)}%`);
      }

      return { stages: report, referenceHigh: ref };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PWM MODULATION TEST
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test de modulaciÃ³n PWM (Pulse Width Modulation) vÃ­a AudioParam.
     * 
     * Simula la conexiÃ³n de la matriz de audio Panel 5 al AudioParam
     * 'pulseWidth' del oscilador, emulando el comportamiento del CEM 3340.
     *
     * Compara el espectro de una onda pulse con y sin modulaciÃ³n PWM:
     * - Sin modulaciÃ³n: pulse con duty cycle fijo â†’ solo armÃ³nicos impares (50%)
     *   o espectro estÃ¡tico con nulls en mÃºltiplos de 1/duty
     * - Con modulaciÃ³n: el barrido del duty cycle produce un espectro mÃ¡s
     *   "lleno" (armÃ³nicos pares aparecen) y efectos tipo chorus/ensemble
     *
     * @param {Object} config
     * @param {number} config.carrierFreq - Frecuencia del oscilador portador
     * @param {number} config.modFreq - Frecuencia del LFO modulador
     * @param {number} config.modDepth - Profundidad de modulaciÃ³n (0-0.49)
     * @param {number} config.basePulseWidth - Duty cycle base (0.01-0.99)
     * @param {number} config.duration - DuraciÃ³n del render en segundos
     * @param {number} config.sampleRate - Sample rate
     * @returns {Object} Resultado con espectros comparativos
     */
    window.testPWMModulation = async function(config) {
      const {
        carrierFreq = 440,
        modFreq = 5,
        modDepth = 0.3,
        basePulseWidth = 0.5,
        duration = 1.0,
        sampleRate = 44100
      } = config;

      log(`PWM test: carrier=${carrierFreq}Hz, mod=${modFreq}Hz, depth=${modDepth}, base PW=${basePulseWidth}`);

      const length = Math.ceil(sampleRate * duration);

      // â”€â”€â”€ RENDER SIN MODULACIÃ“N (referencia) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineRef = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineRef.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const oscRef = new AudioWorkletNode(offlineRef, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: false },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscRef.parameters.get('frequency').value = carrierFreq;
      oscRef.parameters.get('pulseWidth').value = basePulseWidth;
      oscRef.parameters.get('gain').value = 1.0;
      oscRef.connect(offlineRef.destination);

      const bufferRef = await offlineRef.startRendering();
      const samplesRef = bufferRef.getChannelData(0);

      // â”€â”€â”€ RENDER CON MODULACIÃ“N PWM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineMod = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineMod.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Oscilador portador (pulse)
      const oscMod = new AudioWorkletNode(offlineMod, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: false },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscMod.parameters.get('frequency').value = carrierFreq;
      oscMod.parameters.get('pulseWidth').value = basePulseWidth;
      oscMod.parameters.get('gain').value = 1.0;

      // LFO modulador (usa OscillatorNode nativo para simplicidad)
      const lfo = offlineMod.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = modFreq;

      // GainNode para controlar profundidad de modulaciÃ³n
      // modDepth: amplitud del LFO en unidades de pulseWidth
      const lfoGain = offlineMod.createGain();
      lfoGain.gain.value = modDepth;

      // Conectar LFO â†’ gain â†’ pulseWidth AudioParam
      lfo.connect(lfoGain);
      lfoGain.connect(oscMod.parameters.get('pulseWidth'));
      lfo.start(0);

      oscMod.connect(offlineMod.destination);

      const bufferMod = await offlineMod.startRendering();
      const samplesMod = bufferMod.getChannelData(0);

      // â”€â”€â”€ ANÃLISIS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const spectrumRef = computeSpectrum(samplesRef, sampleRate);
      const spectrumMod = computeSpectrum(samplesMod, sampleRate);

      // Calcular RMS de ambas seÃ±ales
      const rmsRef = calculateRMS(samplesRef);
      const rmsMod = calculateRMS(samplesMod);

      // Analizar diferencia espectral: con PWM, armÃ³nicos pares deben aparecer
      // (si basePulseWidth=0.5, sin mod solo hay impares)
      const h1Ref = spectrumRef.find(b => b.frequency > carrierFreq * 0.9 && b.frequency < carrierFreq * 1.1);
      const h2Ref = spectrumRef.find(b => b.frequency > carrierFreq * 1.9 && b.frequency < carrierFreq * 2.1);
      const h3Ref = spectrumRef.find(b => b.frequency > carrierFreq * 2.9 && b.frequency < carrierFreq * 3.1);

      const h1Mod = spectrumMod.find(b => b.frequency > carrierFreq * 0.9 && b.frequency < carrierFreq * 1.1);
      const h2Mod = spectrumMod.find(b => b.frequency > carrierFreq * 1.9 && b.frequency < carrierFreq * 2.1);
      const h3Mod = spectrumMod.find(b => b.frequency > carrierFreq * 2.9 && b.frequency < carrierFreq * 3.1);

      // Sidebands: con PWM, aparecen frecuencias a carrier Â± modFreq
      const sideband1 = spectrumMod.find(b => 
        b.frequency > (carrierFreq - modFreq * 1.5) && b.frequency < (carrierFreq - modFreq * 0.5));
      const sideband2 = spectrumMod.find(b => 
        b.frequency > (carrierFreq + modFreq * 0.5) && b.frequency < (carrierFreq + modFreq * 1.5));

      return {
        config,
        reference: {
          rms: rmsRef,
          peak: calculatePeak(samplesRef),
          h1: h1Ref, h2: h2Ref, h3: h3Ref,
          samplePreview: Array.from(samplesRef.slice(0, 512))
        },
        modulated: {
          rms: rmsMod,
          peak: calculatePeak(samplesMod),
          h1: h1Mod, h2: h2Mod, h3: h3Mod,
          sideband1, sideband2,
          samplePreview: Array.from(samplesMod.slice(0, 512))
        },
        // ComparaciÃ³n directa
        spectralDifference: {
          h2Increase: (h2Mod?.magnitude ?? 0) - (h2Ref?.magnitude ?? 0),
          hasSidebands: (sideband1?.magnitude ?? 0) > 0.001 || (sideband2?.magnitude ?? 0) > 0.001
        }
      };
    };

    /**
     * Test de PWM en extremos: verifica colapso a DC cuando duty cycle
     * se acerca a 0% o 100%.
     * 
     * Basado en especificaciones CEM 3340:
     * - En duty 0% o 100%, la seÃ±al colapsa a DC (silencio AC)
     * - Justo antes, solo quedan armÃ³nicos superiores ("thin buzz")
     */
    window.testPWMExtremes = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`PWM extremes test @ ${frequency}Hz`);

      const results = {};
      const testWidths = [0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99];

      for (const pw of testWidths) {
        const length = Math.ceil(sampleRate * duration);
        const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
        await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

        const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
          processorOptions: { mode: 'single', waveform: 'pulse', moduleSlewEnabled: false },
          numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
        });
        osc.parameters.get('frequency').value = frequency;
        osc.parameters.get('pulseWidth').value = pw;
        osc.parameters.get('gain').value = 1.0;
        osc.connect(offline.destination);

        const buffer = await offline.startRendering();
        const samples = buffer.getChannelData(0);

        const rms = calculateRMS(samples);

        // Calcular media (componente DC) y RMS-AC
        let sum = 0;
        for (let j = 0; j < samples.length; j++) sum += samples[j];
        const mean = sum / samples.length;

        // AC RMS: RMS con DC eliminada (lo que realmente importa para audio)
        let acSum = 0;
        for (let j = 0; j < samples.length; j++) {
          const ac = samples[j] - mean;
          acSum += ac * ac;
        }
        const acRms = Math.sqrt(acSum / samples.length);

        results[pw] = {
          rms,
          acRms,
          mean,
          peak: calculatePeak(samples),
          zeroCrossings: (() => {
            let c = 0;
            for (let i = 1; i < samples.length; i++) {
              if ((samples[i-1] < 0 && samples[i] >= 0) || (samples[i-1] >= 0 && samples[i] < 0)) c++;
            }
            return c;
          })()
        };
      }

      return { config, results };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INICIALIZACIÃ“N
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function init() {
      try {
        log('Verificando soporte Web Audio...');
        
        if (!window.AudioContext && !window.webkitAudioContext) {
          throw new Error('Web Audio API no soportada');
        }
        
        if (!window.OfflineAudioContext) {
          throw new Error('OfflineAudioContext no soportado');
        }
        
        // Test rÃ¡pido de AudioWorklet
        const testCtx = new OfflineAudioContext(1, 1024, 44100);
        if (!testCtx.audioWorklet) {
          throw new Error('AudioWorklet no soportado');
        }
        
        log('Web Audio API disponible', 'success');
        log('OfflineAudioContext disponible', 'success');
        log('AudioWorklet disponible', 'success');
        
        setStatus('âœ… Harness listo para tests de audio', 'ready');
        
        // Marcar como listo para Playwright
        window.__AUDIO_HARNESS_READY__ = true;
        
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        setStatus(`âŒ Error: ${error.message}`, 'error');
        window.__AUDIO_HARNESS_READY__ = false;
      }
    }

    init();
  </script>
</body>
</html>
