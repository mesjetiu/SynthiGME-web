<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SynthiGME Audio Test Harness</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 2rem auto;
      padding: 1rem;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #00d9ff; }
    .status { 
      padding: 0.5rem 1rem; 
      border-radius: 4px; 
      margin: 0.5rem 0;
    }
    .ready { background: #0f5132; }
    .loading { background: #664d03; }
    .error { background: #842029; }
    #log {
      background: #0d0d0d;
      padding: 1rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
    .log-entry { margin: 0.25rem 0; }
    .log-entry.info { color: #6c757d; }
    .log-entry.success { color: #198754; }
    .log-entry.error { color: #dc3545; }
  </style>
</head>
<body>
  <h1>ğŸ›ï¸ SynthiGME Audio Test Harness</h1>
  
  <div id="status" class="status loading">Cargando worklets...</div>
  
  <div id="log"></div>

  <script type="module">
    /**
     * Audio Test Harness
     * 
     * Este archivo se carga en Playwright y expone funciones globales
     * para ejecutar tests de audio con Web Audio API real.
     * 
     * Los tests llaman a estas funciones via page.evaluate().
     */

    const log = (msg, type = 'info') => {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toISOString().slice(11, 23)}] ${msg}`;
      document.getElementById('log').appendChild(entry);
      console.log(`[AudioHarness] ${msg}`);
    };

    const setStatus = (msg, type) => {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = `status ${type}`;
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS DE ANÃLISIS ESPECTRAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Calcula el espectro de magnitud usando DFT simple (mÃ¡s lento pero confiable).
     * Solo calcula los bins necesarios para el anÃ¡lisis.
     */
    function computeSpectrum(samples, sampleRate) {
      const N = samples.length;
      const spectrum = [];
      
      // Solo calcular hasta Nyquist y con resoluciÃ³n razonable
      const maxBins = Math.min(N / 2, 2048);
      const binStep = Math.max(1, Math.floor(N / 2 / maxBins));
      
      for (let k = 1; k < maxBins; k++) {
        const binIndex = k * binStep;
        let re = 0;
        let im = 0;
        
        // DFT para este bin especÃ­fico
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * binIndex * n / N;
          re += samples[n] * Math.cos(angle);
          im += samples[n] * Math.sin(angle);
        }
        
        const magnitude = Math.sqrt(re * re + im * im) / N;
        const db = 20 * Math.log10(magnitude + 1e-10);
        const frequency = binIndex * sampleRate / N;
        
        spectrum.push({
          bin: binIndex,
          frequency,
          magnitude,
          db
        });
      }
      
      return spectrum;
    }

    /**
     * VersiÃ³n rÃ¡pida: usa zero-crossing para estimar frecuencia
     * y picos para anÃ¡lisis bÃ¡sico de armÃ³nicos.
     */
    function analyzeSignalFast(samples, sampleRate) {
      // Estimar frecuencia por zero crossings
      let crossings = 0;
      for (let i = 1; i < samples.length; i++) {
        if ((samples[i - 1] < 0 && samples[i] >= 0)) {
          crossings++;
        }
      }
      const duration = samples.length / sampleRate;
      const estimatedFreq = crossings / duration;
      
      // Calcular RMS y peak
      let sum = 0;
      let peak = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
        if (Math.abs(samples[i]) > peak) peak = Math.abs(samples[i]);
      }
      const rms = Math.sqrt(sum / samples.length);
      
      return {
        estimatedFreq,
        rms,
        peak
      };
    }

    /**
     * Encuentra la frecuencia dominante en el espectro.
     */
    function findDominantFrequency(spectrum, minDb = -80) {
      let maxMag = 0;
      let dominant = null;
      
      // Ignorar DC (bin 0) y frecuencias muy bajas
      for (let i = 1; i < spectrum.length; i++) {
        const bin = spectrum[i];
        if (bin.magnitude > maxMag && bin.frequency > 10) {
          maxMag = bin.magnitude;
          dominant = bin;
        }
      }
      
      return dominant;
    }

    /**
     * Encuentra armÃ³nicos de una frecuencia fundamental.
     */
    function findHarmonics(spectrum, fundamental, count = 5, tolerance = 5) {
      const harmonics = [];
      
      for (let n = 1; n <= count; n++) {
        const targetFreq = fundamental * n;
        let best = null;
        let bestDiff = Infinity;
        
        for (const bin of spectrum) {
          const diff = Math.abs(bin.frequency - targetFreq);
          if (diff < tolerance && diff < bestDiff) {
            bestDiff = diff;
            best = bin;
          }
        }
        
        harmonics.push({
          harmonic: n,
          expected: targetFreq,
          found: best
        });
      }
      
      return harmonics;
    }

    /**
     * Calcula la DistorsiÃ³n ArmÃ³nica Total (THD).
     */
    function measureTHD(spectrum, fundamental, numHarmonics = 5) {
      const harmonics = findHarmonics(spectrum, fundamental, numHarmonics + 1);
      
      const fundamentalMag = harmonics[0]?.found?.magnitude || 0;
      if (fundamentalMag === 0) return null;
      
      let harmonicPower = 0;
      for (let i = 1; i < harmonics.length; i++) {
        const mag = harmonics[i]?.found?.magnitude || 0;
        harmonicPower += mag * mag;
      }
      
      return Math.sqrt(harmonicPower) / fundamentalMag * 100; // Porcentaje
    }

    /**
     * Calcula RMS de una seÃ±al.
     */
    function calculateRMS(samples) {
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i] * samples[i];
      }
      return Math.sqrt(sum / samples.length);
    }

    /**
     * Calcula el pico de una seÃ±al.
     */
    function calculatePeak(samples) {
      let max = 0;
      for (let i = 0; i < samples.length; i++) {
        const abs = Math.abs(samples[i]);
        if (abs > max) max = abs;
      }
      return max;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FUNCIONES DE TEST EXPUESTAS GLOBALMENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Renderiza audio de un oscilador con OfflineAudioContext.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {string} config.waveform - Tipo de onda: 'sine'|'sawtooth'|'triangle'|'pulse'
     * @param {number} config.frequency - Frecuencia en Hz
     * @param {number} config.duration - DuraciÃ³n en segundos
     * @param {number} [config.pulseWidth=0.5] - Ancho de pulso (0.01-0.99)
     * @param {number} [config.symmetry=0.5] - SimetrÃ­a del sine (0-1)
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testSynthOscillator = async function(config) {
      const {
        waveform = 'sine',
        frequency = 440,
        duration = 0.5,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering ${waveform} @ ${frequency}Hz, duration=${duration}s`);

      // Crear OfflineAudioContext
      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      log('Worklet registrado');

      // Crear nodo de oscilador
      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform,
          sineShapeAttenuation: 0,  // Sin atenuaciÃ³n para tests de forma pura
          sinePurity: 1.0            // Seno puro en centro
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('gain').value = 1.0;

      // Conectar a destino
      oscillator.connect(offline.destination);

      // Renderizar
      log('Iniciando render...');
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;
      log(`Render completado en ${renderTime.toFixed(1)}ms`, 'success');

      // Obtener samples
      const samples = buffer.getChannelData(0);
      
      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const harmonics = findHarmonics(spectrum, frequency, 10);
      const thd = measureTHD(spectrum, frequency, 5);
      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      // Verificar forma de onda (primeros N samples para anÃ¡lisis de fase)
      const phaseAnalysis = {
        startValue: samples[0],
        quarterCycle: samples[Math.floor(sampleRate / frequency / 4)],
        halfCycle: samples[Math.floor(sampleRate / frequency / 2)],
        threeQuarterCycle: samples[Math.floor(sampleRate / frequency * 0.75)]
      };

      return {
        config,
        renderTime,
        sampleCount: samples.length,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        harmonics: harmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? {
            frequency: h.found.frequency,
            magnitude: h.found.magnitude,
            db: h.found.db
          } : null
        })),
        thd,
        rms,
        peak,
        phaseAnalysis,
        // Incluir algunos samples para verificaciÃ³n visual
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * Renderiza audio con mÃºltiples formas de onda simultÃ¡neas (modo multi).
     */
    window.testSynthOscillatorMulti = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sineLevel = 1,
        sawLevel = 0,
        triLevel = 0,
        pulseLevel = 0,
        pulseWidth = 0.5,
        symmetry = 0.5,
        sampleRate = 44100
      } = config;

      log(`Rendering multi-waveform @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 2,  // 2 canales: sine+saw, tri+pulse
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'multi',
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 2,
        outputChannelCount: [1, 1]
      });

      // Configurar parÃ¡metros
      oscillator.parameters.get('frequency').value = frequency;
      oscillator.parameters.get('pulseWidth').value = pulseWidth;
      oscillator.parameters.get('symmetry').value = symmetry;
      oscillator.parameters.get('sineLevel').value = sineLevel;
      oscillator.parameters.get('sawLevel').value = sawLevel;
      oscillator.parameters.get('triLevel').value = triLevel;
      oscillator.parameters.get('pulseLevel').value = pulseLevel;

      // Crear merger para capturar ambos canales
      const merger = offline.createChannelMerger(2);
      oscillator.connect(merger, 0, 0);  // sine+saw â†’ canal 0
      oscillator.connect(merger, 1, 1);  // tri+pulse â†’ canal 1
      merger.connect(offline.destination);

      const buffer = await offline.startRendering();
      
      const channel0 = buffer.getChannelData(0);  // sine + saw
      const channel1 = buffer.getChannelData(1);  // tri + pulse

      return {
        config,
        channel0: {
          rms: calculateRMS(channel0),
          peak: calculatePeak(channel0),
          spectrum: computeSpectrum(channel0, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel0.slice(0, 256))
        },
        channel1: {
          rms: calculateRMS(channel1),
          peak: calculatePeak(channel1),
          spectrum: computeSpectrum(channel1, sampleRate).slice(0, 100),
          samplePreview: Array.from(channel1.slice(0, 256))
        }
      };
    };

    /**
     * Renderiza audio a travÃ©s de una cadena de nodos (simula matriz).
     * Ãštil para tests de routing y ganancias.
     */
    window.testSignalRouting = async function(config) {
      const {
        sourceFrequency = 440,
        sourceWaveform = 'sine',
        gains = [1.0],  // Array de ganancias a aplicar en cadena
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Routing test: ${sourceWaveform}@${sourceFrequency}Hz through ${gains.length} gain stages`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador fuente
      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: sourceWaveform }
      });
      osc.parameters.get('frequency').value = sourceFrequency;
      osc.parameters.get('gain').value = 1.0;

      // Crear cadena de ganancias (simulando pines de matriz)
      let lastNode = osc;
      const gainNodes = [];
      
      for (const gainValue of gains) {
        const gainNode = offline.createGain();
        gainNode.gain.value = gainValue;
        lastNode.connect(gainNode);
        lastNode = gainNode;
        gainNodes.push({ requestedGain: gainValue, actualGain: gainNode.gain.value });
      }

      lastNode.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Calcular ganancia total esperada vs real
      const expectedTotalGain = gains.reduce((a, b) => a * b, 1.0);
      const actualPeak = calculatePeak(samples);

      return {
        config,
        gainNodes,
        expectedTotalGain,
        actualPeak,
        rms: calculateRMS(samples),
        spectrum: computeSpectrum(samples, sampleRate).slice(0, 200)  // MÃ¡s bins para mejor resoluciÃ³n
      };
    };

    /**
     * Test de latencia: mide el tiempo desde trigger hasta primer sample no-cero.
     */
    window.testLatency = async function(config) {
      const {
        frequency = 1000,
        sampleRate = 44100,
        duration = 0.1
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'pulse' }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Encontrar primer sample con seÃ±al significativa
      let firstNonZeroIndex = -1;
      const threshold = 0.001;
      for (let i = 0; i < samples.length; i++) {
        if (Math.abs(samples[i]) > threshold) {
          firstNonZeroIndex = i;
          break;
        }
      }

      const latencySamples = firstNonZeroIndex;
      const latencyMs = latencySamples >= 0 ? (latencySamples / sampleRate * 1000) : null;

      return {
        latencySamples,
        latencyMs,
        firstSamples: Array.from(samples.slice(0, 20))
      };
    };

    /**
     * Test de anti-aliasing: verifica que no hay frecuencias espurias sobre Nyquist.
     */
    window.testAntiAliasing = async function(config) {
      const {
        frequency = 10000,  // Alta frecuencia para provocar aliasing
        waveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Anti-aliasing test: ${waveform} @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const osc = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform }
      });
      osc.parameters.get('frequency').value = frequency;
      osc.parameters.get('gain').value = 1.0;
      osc.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);
      const spectrum = computeSpectrum(samples, sampleRate);

      // Encontrar frecuencias significativas (> -40dB)
      const significantFreqs = spectrum.filter(bin => bin.db > -40);
      
      // Calcular quÃ© armÃ³nicos deberÃ­an existir vs cuÃ¡les estÃ¡n aliasados
      const nyquist = sampleRate / 2;
      const expectedHarmonics = [];
      const aliasedHarmonics = [];
      
      for (let n = 1; n <= 20; n++) {
        const harmonicFreq = frequency * n;
        if (harmonicFreq < nyquist) {
          expectedHarmonics.push({ n, frequency: harmonicFreq });
        } else {
          // Frecuencia aliasada = |freq - N * sampleRate|
          const aliasedFreq = Math.abs(harmonicFreq - Math.round(harmonicFreq / sampleRate) * sampleRate);
          aliasedHarmonics.push({ n, original: harmonicFreq, aliased: aliasedFreq });
        }
      }

      // Verificar que no hay energÃ­a significativa en frecuencias aliasadas
      const aliasingDetected = [];
      for (const alias of aliasedHarmonics) {
        const found = spectrum.find(bin => 
          Math.abs(bin.frequency - alias.aliased) < 20 && bin.db > -50
        );
        if (found) {
          aliasingDetected.push({
            ...alias,
            detectedMagnitude: found.magnitude,
            detectedDb: found.db
          });
        }
      }

      return {
        config,
        nyquist,
        expectedHarmonics: expectedHarmonics.length,
        aliasedHarmonics: aliasedHarmonics.length,
        aliasingDetected,
        hasAliasing: aliasingDetected.length > 0,
        significantFreqs: significantFreqs.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        }))
      };
    };

    /**
     * Test de Niveles de Voltaje de Salida por Forma de Onda
     * 
     * Verifica que las amplitudes relativas entre formas de onda cumplen
     * los ratios especificados en el Manual TÃ©cnico Datanomics (1982):
     * 
     * | Forma      | Voltaje   | Ratio vs Seno |
     * |------------|-----------|---------------|
     * | Seno       | 8.0V p-p  | 1.000         |
     * | Sierra     | 6.2V p-p  | 0.775         |
     * | TriÃ¡ngulo  | 8.1V p-p  | 1.0125        |
     * | Pulso      | 8.1V p-p  | 1.0125        |
     * | Cuspoide   | 0.5V p-p  | 0.0625 (1/16) |
     * 
     * NOTA: Cuspoide = Seno con symmetry=0 o symmetry=1 y sineShapeAttenuation=1
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} [config.frequency=440] - Frecuencia de test (Hz)
     * @param {number} [config.duration=0.5] - DuraciÃ³n de render (s)
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @param {boolean} [config.testCusp=false] - Si debe testear cuspoide
     * @returns {Object} Amplitudes y ratios medidos
     */
    window.testWaveformAmplitudes = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sampleRate = 44100,
        testCusp = false
      } = config;

      log(`Testing waveform amplitudes @ ${frequency}Hz, testCusp=${testCusp}`);

      const length = Math.ceil(sampleRate * duration);
      const waveforms = ['sine', 'sawtooth', 'triangle', 'pulse'];
      const results = {};

      // Medir amplitud de cada forma de onda bÃ¡sica
      for (const waveform of waveforms) {
        const offline = new OfflineAudioContext({
          numberOfChannels: 1,
          length,
          sampleRate
        });

        await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

        const oscillator = new AudioWorkletNode(offline, 'synth-oscillator', {
          processorOptions: {
            mode: 'single',
            waveform,
            sineShapeAttenuation: 0,  // Sin atenuaciÃ³n de forma
            sinePurity: 1.0            // Seno puro
          },
          numberOfInputs: 1,
          numberOfOutputs: 1,
          outputChannelCount: [1]
        });

        oscillator.parameters.get('frequency').value = frequency;
        oscillator.parameters.get('pulseWidth').value = 0.5;  // Duty 50% para pulse
        oscillator.parameters.get('symmetry').value = 0.5;    // Centro para sine
        oscillator.parameters.get('gain').value = 1.0;

        oscillator.connect(offline.destination);

        const buffer = await offline.startRendering();
        const samples = buffer.getChannelData(0);

        results[waveform] = {
          peak: calculatePeak(samples),
          rms: calculateRMS(samples)
        };

        log(`  ${waveform}: peak=${results[waveform].peak.toFixed(4)}, rms=${results[waveform].rms.toFixed(4)}`);
      }

      // Testear cuspoide si se solicita (seno con symmetry extrema y atenuaciÃ³n)
      if (testCusp) {
        // Cuspoide = seno con symmetry=0 (o 1) y sineShapeAttenuation=1
        const offlineCusp = new OfflineAudioContext({
          numberOfChannels: 1,
          length,
          sampleRate
        });

        await offlineCusp.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

        const cuspOscillator = new AudioWorkletNode(offlineCusp, 'synth-oscillator', {
          processorOptions: {
            mode: 'single',
            waveform: 'sine',
            sineShapeAttenuation: 1.0,  // AtenuaciÃ³n completa activada
            sinePurity: 1.0
          },
          numberOfInputs: 1,
          numberOfOutputs: 1,
          outputChannelCount: [1]
        });

        cuspOscillator.parameters.get('frequency').value = frequency;
        cuspOscillator.parameters.get('symmetry').value = 0;  // Extremo = cuspoide
        cuspOscillator.parameters.get('gain').value = 1.0;

        cuspOscillator.connect(offlineCusp.destination);

        const cuspBuffer = await offlineCusp.startRendering();
        const cuspSamples = cuspBuffer.getChannelData(0);

        results.cusp = {
          peak: calculatePeak(cuspSamples),
          rms: calculateRMS(cuspSamples)
        };

        log(`  cusp: peak=${results.cusp.peak.toFixed(4)}, rms=${results.cusp.rms.toFixed(4)}`);
      }

      // Calcular ratios respecto al seno
      const sinePeak = results.sine.peak;
      const ratios = {};

      for (const [waveform, data] of Object.entries(results)) {
        ratios[waveform] = {
          vsReference: data.peak / sinePeak,  // Ratio vs seno
          peakToRms: data.peak / data.rms     // Crest factor
        };
      }

      // Voltajes esperados segÃºn Datanomics 1982 (normalizados a seno=1.0)
      const expectedRatios = {
        sine: 8.0 / 8.0,       // 1.0000
        sawtooth: 6.2 / 8.0,   // 0.7750
        triangle: 8.1 / 8.0,   // 1.0125
        pulse: 8.1 / 8.0,      // 1.0125
        cusp: 0.5 / 8.0        // 0.0625 (1/16)
      };

      return {
        config,
        measurements: results,
        ratios,
        expectedRatios,
        sinePeak,  // Para referencia
        // Diferencias para validaciÃ³n
        differences: Object.fromEntries(
          Object.entries(ratios).map(([waveform, data]) => [
            waveform,
            {
              measured: data.vsReference,
              expected: expectedRatios[waveform],
              error: data.vsReference - expectedRatios[waveform],
              errorPercent: ((data.vsReference - expectedRatios[waveform]) / expectedRatios[waveform] * 100)
            }
          ])
        )
      };
    };

    /**
     * Test especÃ­fico de atenuaciÃ³n cuspoide vs seno puro
     * 
     * Verifica el ratio de atenuaciÃ³n 8:1 documentado en el manual:
     * - Seno puro (symmetry=0.5): amplitud completa
     * - Cuspoide (symmetry=0 o 1): amplitud reducida a 1/8
     * 
     * @param {Object} config - ConfiguraciÃ³n
     * @returns {Object} ComparaciÃ³n seno vs cuspoide
     */
    window.testCuspAttenuation = async function(config) {
      const {
        frequency = 440,
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Testing cusp attenuation @ ${frequency}Hz`);

      const length = Math.ceil(sampleRate * duration);

      // === SENO PURO (symmetry=0.5, sin atenuaciÃ³n) ===
      const offlinePure = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlinePure.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const pureSine = new AudioWorkletNode(offlinePure, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'sine',
          sineShapeAttenuation: 1.0,  // AtenuaciÃ³n activa (pero no aplica en centro)
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      pureSine.parameters.get('frequency').value = frequency;
      pureSine.parameters.get('symmetry').value = 0.5;  // Centro = seno puro
      pureSine.parameters.get('gain').value = 1.0;
      pureSine.connect(offlinePure.destination);

      const pureBuf = await offlinePure.startRendering();
      const pureSamples = pureBuf.getChannelData(0);

      // === CUSPOIDE (symmetry=0, con atenuaciÃ³n) ===
      const offlineCusp = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineCusp.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const cuspSine = new AudioWorkletNode(offlineCusp, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: 'sine',
          sineShapeAttenuation: 1.0,  // AtenuaciÃ³n completa
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });

      cuspSine.parameters.get('frequency').value = frequency;
      cuspSine.parameters.get('symmetry').value = 0;  // Extremo = cuspoide mÃ¡xima
      cuspSine.parameters.get('gain').value = 1.0;
      cuspSine.connect(offlineCusp.destination);

      const cuspBuf = await offlineCusp.startRendering();
      const cuspSamples = cuspBuf.getChannelData(0);

      // Calcular mÃ©tricas
      const purePeak = calculatePeak(pureSamples);
      const cuspPeak = calculatePeak(cuspSamples);
      const pureRms = calculateRMS(pureSamples);
      const cuspRms = calculateRMS(cuspSamples);

      // Ratio medido vs esperado (8:1 = 0.125)
      const measuredRatio = cuspPeak / purePeak;
      const expectedRatio = 0.125;  // 1/8 = 0.5V / 4V segÃºn manual

      log(`  Pure sine: peak=${purePeak.toFixed(4)}, rms=${pureRms.toFixed(4)}`);
      log(`  Cusp form: peak=${cuspPeak.toFixed(4)}, rms=${cuspRms.toFixed(4)}`);
      log(`  Ratio cusp/pure: ${measuredRatio.toFixed(4)} (expected: ${expectedRatio})`);

      return {
        config,
        pureSine: {
          peak: purePeak,
          rms: pureRms
        },
        cuspForm: {
          peak: cuspPeak,
          rms: cuspRms
        },
        attenuation: {
          measuredRatio,
          expectedRatio,
          inverseRatio: 1 / measuredRatio,  // DeberÃ­a ser ~8
          error: measuredRatio - expectedRatio,
          errorPercent: (measuredRatio - expectedRatio) / expectedRatio * 100
        }
      };
    };

    /**
     * Test de Hard Sync: un oscilador "slave" sincronizado por un "master".
     * 
     * El hard sync resetea la fase del slave cada vez que el master cruza
     * por cero en direcciÃ³n positiva. Esto produce:
     * - La frecuencia fundamental del output sigue al master
     * - El timbre es rico en armÃ³nicos (mÃ¡s que el slave solo)
     * - Diferentes ratios master/slave producen diferentes timbres
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.masterFrequency - Frecuencia del oscilador master (Hz)
     * @param {number} config.slaveFrequency - Frecuencia del oscilador slave (Hz)
     * @param {string} [config.masterWaveform='sine'] - Forma de onda del master
     * @param {string} [config.slaveWaveform='sawtooth'] - Forma de onda del slave
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis
     */
    window.testHardSync = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        masterWaveform = 'sine',
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync test: master ${masterWaveform}@${masterFrequency}Hz â†’ slave ${slaveWaveform}@${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      // Registrar el worklet
      await offline.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      // Crear oscilador MASTER (proporciona la seÃ±al de sync)
      const master = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: masterWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      // Crear oscilador SLAVE (recibe sync en input 0)
      // NOTA: channelCountMode: 'explicit' + channelCount: 1 asegura que el input
      // tenga exactamente 1 canal incluso cuando el AudioWorklet lo procesa.
      const slave = new AudioWorkletNode(offline, 'synth-oscillator', {
        processorOptions: {
          mode: 'single',
          waveform: slaveWaveform,
          sineShapeAttenuation: 0,
          sinePurity: 1.0
        },
        numberOfInputs: 1,  // Input 0 = sync input
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      // Conectar: master â†’ slave input 0 (sync)
      // El slave detecta flancos positivos del master y resetea su fase
      // IMPORTANTE: Usar connect(dest, outputIndex, inputIndex) para especificar
      // explÃ­citamente que conectamos al input 0 del worklet.
      master.connect(slave, 0, 0);

      // Solo el slave va a la salida
      slave.connect(offline.destination);

      // Renderizar
      const startTime = performance.now();
      const buffer = await offline.startRendering();
      const renderTime = performance.now() - startTime;

      const samples = buffer.getChannelData(0);

      // AnÃ¡lisis
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      
      // Encontrar armÃ³nicos del master (la frecuencia fundamental debe ser del master)
      const masterHarmonics = findHarmonics(spectrum, masterFrequency, 10);
      
      // Encontrar armÃ³nicos del slave (para comparar)
      const slaveHarmonics = findHarmonics(spectrum, slaveFrequency, 5);

      // Contar armÃ³nicos significativos (> -40dB)
      const significantHarmonics = spectrum.filter(b => b.db > -40 && b.frequency > 50);

      // Calcular riqueza armÃ³nica (cuÃ¡ntos armÃ³nicos significativos hay)
      const harmonicRichness = significantHarmonics.length;

      // Calcular la energÃ­a en la frecuencia del master vs slave
      const masterBin = spectrum.find(b => Math.abs(b.frequency - masterFrequency) < 20);
      const slaveBin = spectrum.find(b => Math.abs(b.frequency - slaveFrequency) < 20);

      const rms = calculateRMS(samples);
      const peak = calculatePeak(samples);

      log(`Hard Sync render: ${renderTime.toFixed(1)}ms, dominant: ${dominant?.frequency.toFixed(1)}Hz`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, masterWaveform, slaveWaveform, duration },
        renderTime,
        dominant: dominant ? {
          frequency: dominant.frequency,
          magnitude: dominant.magnitude,
          db: dominant.db
        } : null,
        masterHarmonics: masterHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        slaveHarmonics: slaveHarmonics.map(h => ({
          harmonic: h.harmonic,
          expected: h.expected,
          found: h.found ? { frequency: h.found.frequency, magnitude: h.found.magnitude, db: h.found.db } : null
        })),
        masterEnergy: masterBin ? masterBin.magnitude : 0,
        slaveEnergy: slaveBin ? slaveBin.magnitude : 0,
        harmonicRichness,
        significantFreqs: significantHarmonics.slice(0, 20).map(f => ({
          frequency: f.frequency,
          db: f.db
        })),
        rms,
        peak,
        samplePreview: Array.from(samples.slice(0, 256))
      };
    };

    /**
     * DiagnÃ³stico de Hard Sync: verifica que el input estÃ¡ llegando al worklet.
     * Renderiza master solo y captura cruces por cero.
     */
    window.diagnoseSyncInput = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        duration = 0.1,
        sampleRate = 44100
      } = config;

      log(`Diagnosing sync input: master=${masterFrequency}Hz, slave=${slaveFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);
      
      // Renderizar solo el master para ver su forma de onda
      const offlineMaster = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineMaster.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const masterAlone = new AudioWorkletNode(offlineMaster, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      masterAlone.parameters.get('frequency').value = masterFrequency;
      masterAlone.parameters.get('gain').value = 1.0;
      masterAlone.connect(offlineMaster.destination);

      const masterBuffer = await offlineMaster.startRendering();
      const masterSamples = masterBuffer.getChannelData(0);

      // Contar cruces por cero (flancos positivos)
      let positiveCrossings = 0;
      for (let i = 1; i < masterSamples.length; i++) {
        if (masterSamples[i] > 0 && masterSamples[i-1] <= 0) {
          positiveCrossings++;
        }
      }
      const expectedCrossings = Math.round(masterFrequency * duration);

      // Ahora renderizar master + slave para ver si hay diferencia
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slave = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slave.parameters.get('frequency').value = slaveFrequency;
      slave.parameters.get('gain').value = 1.0;

      master.connect(slave, 0, 0);
      slave.connect(offlineSync.destination);

      const syncBuffer = await offlineSync.startRendering();
      const syncSamples = syncBuffer.getChannelData(0);

      // Renderizar slave sin sync para comparar
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveAlone = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sawtooth' },
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      slaveAlone.parameters.get('frequency').value = slaveFrequency;
      slaveAlone.parameters.get('gain').value = 1.0;
      slaveAlone.connect(offlineNoSync.destination);

      const noSyncBuffer = await offlineNoSync.startRendering();
      const noSyncSamples = noSyncBuffer.getChannelData(0);

      // Comparar si hay diferencia entre sync y no-sync
      let diffSum = 0;
      for (let i = 0; i < syncSamples.length; i++) {
        diffSum += Math.abs(syncSamples[i] - noSyncSamples[i]);
      }
      const avgDiff = diffSum / syncSamples.length;

      log(`Diagnosis: masterCrossings=${positiveCrossings}/${expectedCrossings}, avgDiff=${avgDiff.toFixed(6)}`, avgDiff > 0.01 ? 'success' : 'error');

      return {
        masterFrequency,
        slaveFrequency,
        duration,
        positiveCrossings,
        expectedCrossings,
        crossingsMatch: Math.abs(positiveCrossings - expectedCrossings) <= 1,
        avgDiffWithWithoutSync: avgDiff,
        syncHasEffect: avgDiff > 0.01,
        masterSamples: Array.from(masterSamples.slice(0, 512)),
        syncSamples: Array.from(syncSamples.slice(0, 512)),
        noSyncSamples: Array.from(noSyncSamples.slice(0, 512))
      };
    };

    /**
     * Test comparativo: mismo oscilador con y sin hard sync.
     * Ãštil para verificar que el sync realmente modifica el timbre.
     */
    window.testHardSyncComparison = async function(config) {
      const {
        masterFrequency = 220,
        slaveFrequency = 440,
        slaveWaveform = 'sawtooth',
        duration = 0.5,
        sampleRate = 44100
      } = config;

      log(`Hard Sync comparison: slave ${slaveWaveform}@${slaveFrequency}Hz with/without sync@${masterFrequency}Hz`);

      const length = Math.ceil(sampleRate * duration);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SIN SYNC: Solo el slave
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineNoSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineNoSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const slaveOnly = new AudioWorkletNode(offlineNoSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform }
      });
      slaveOnly.parameters.get('frequency').value = slaveFrequency;
      slaveOnly.parameters.get('gain').value = 1.0;
      slaveOnly.connect(offlineNoSync.destination);

      const bufferNoSync = await offlineNoSync.startRendering();
      const samplesNoSync = bufferNoSync.getChannelData(0);
      const spectrumNoSync = computeSpectrum(samplesNoSync, sampleRate);
      const dominantNoSync = findDominantFrequency(spectrumNoSync);
      const harmonicsNoSync = spectrumNoSync.filter(b => b.db > -40 && b.frequency > 50).length;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CON SYNC: Master + Slave sincronizado
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const offlineSync = new OfflineAudioContext({
        numberOfChannels: 1,
        length,
        sampleRate
      });

      await offlineSync.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');

      const master = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: 'sine', sinePurity: 1.0 }
      });
      master.parameters.get('frequency').value = masterFrequency;
      master.parameters.get('gain').value = 1.0;

      const slaveSync = new AudioWorkletNode(offlineSync, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform: slaveWaveform },
        numberOfInputs: 1,
        channelCount: 1,
        channelCountMode: 'explicit'
      });
      slaveSync.parameters.get('frequency').value = slaveFrequency;
      slaveSync.parameters.get('gain').value = 1.0;

      master.connect(slaveSync, 0, 0);  // Sync connection: output 0 â†’ input 0
      slaveSync.connect(offlineSync.destination);

      const bufferSync = await offlineSync.startRendering();
      const samplesSync = bufferSync.getChannelData(0);
      const spectrumSync = computeSpectrum(samplesSync, sampleRate);
      const dominantSync = findDominantFrequency(spectrumSync);
      const harmonicsSync = spectrumSync.filter(b => b.db > -40 && b.frequency > 50).length;

      log(`Comparison: noSync=${dominantNoSync?.frequency.toFixed(1)}Hz (${harmonicsNoSync} harmonics), sync=${dominantSync?.frequency.toFixed(1)}Hz (${harmonicsSync} harmonics)`, 'success');

      return {
        config: { masterFrequency, slaveFrequency, slaveWaveform, duration },
        noSync: {
          dominantFrequency: dominantNoSync?.frequency || 0,
          harmonicCount: harmonicsNoSync,
          rms: calculateRMS(samplesNoSync),
          peak: calculatePeak(samplesNoSync)
        },
        withSync: {
          dominantFrequency: dominantSync?.frequency || 0,
          harmonicCount: harmonicsSync,
          rms: calculateRMS(samplesSync),
          peak: calculatePeak(samplesSync)
        },
        // Cambios esperados con sync:
        // 1. La frecuencia fundamental cambia de slaveFreq a masterFreq
        // 2. Generalmente mÃ¡s armÃ³nicos (timbre mÃ¡s rico)
        frequencyShift: (dominantSync?.frequency || 0) - (dominantNoSync?.frequency || 0),
        harmonicIncrease: harmonicsSync - harmonicsNoSync
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST DE MODULACIÃ“N CV 1V/OCTAVA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Test de modulaciÃ³n de frecuencia por CV con estÃ¡ndar 1V/Octava.
     * 
     * Simula una seÃ±al de voltaje pasando por la matriz con un pin GREY
     * (precisiÃ³n Â±0.5%) hacia la entrada CV de frecuencia del oscilador.
     * 
     * El sistema Synthi 100 usa el estÃ¡ndar 1V/Octava:
     * - +1V de CV â†’ frecuencia Ã— 2 (1 octava arriba)
     * - -1V de CV â†’ frecuencia Ã· 2 (1 octava abajo)
     * 
     * Constantes del sistema (de voltageConstants.js):
     * - DIGITAL_TO_VOLTAGE = 4.0 (1.0 digital = 4V)
     * - VOLTS_PER_OCTAVE = 1.0
     * - Pin GREY = 100kÎ©, ganancia Ã—1
     * 
     * ConfiguraciÃ³n del oscilador (de oscillator.config.js):
     * - cvScale = 2
     * - octavesPerUnit = 0.5
     * - â†’ 1.0 digital = 1 octava
     * 
     * Para que 1V = 1 octava:
     * - 1V = 0.25 digital (1V / 4V)
     * - Necesitamos que el sistema amplifique Ã—4 para compensar
     * - Esto se logra ajustando cvScaleÃ—octavesPerUnit = 2 (en cents: Ã—4800)
     * 
     * En la implementaciÃ³n actual:
     * - cvScale=2, octavesPerUnit=0.5 â†’ centsGain = 1200
     * - 1.0 digital â†’ 1200 cents â†’ 1 octava
     * - Para 1V real (0.25 digital) â†’ necesitamos centsGain = 4800
     * 
     * Este test verifica el comportamiento con la calibraciÃ³n correcta para 1V/Oct.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.baseFrequency - Frecuencia base del oscilador (Hz)
     * @param {number} config.cvVoltage - Voltaje CV a aplicar (positivo o negativo)
     * @param {string} [config.waveform='sine'] - Forma de onda del oscilador
     * @param {string} [config.pinType='GREY'] - Tipo de pin (GREY para precisiÃ³n)
     * @param {boolean} [config.rangeLow=false] - true para rango LO (sub-audio)
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis con frecuencias medidas
     */
    window.testFrequencyCV = async function(config) {
      const {
        baseFrequency = 261,  // C4 (punto central del Synthi)
        cvVoltage = 1.0,      // +1V = +1 octava
        waveform = 'sine',
        pinType = 'GREY',     // Pin de precisiÃ³n
        rangeLow = false,     // HI por defecto
        duration = 0.5,
        sampleRate = 44100
      } = config;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CONSTANTES DEL SISTEMA (replicadas de voltageConstants.js)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const DIGITAL_TO_VOLTAGE = 4.0;  // 1.0 digital = 4V
      const VOLTS_PER_OCTAVE = 1.0;    // EstÃ¡ndar V/Oct
      
      // Resistencias de pines (Rf = 100kÎ© estÃ¡ndar)
      const PIN_GAINS = {
        WHITE: 1.0,    // 100kÎ© / 100kÎ© = 1
        GREY: 1.0,     // 100kÎ© / 100kÎ© = 1 (precisiÃ³n)
        GREEN: 1.47,   // 100kÎ© / 68kÎ© â‰ˆ 1.47
        RED: 37.04,    // 100kÎ© / 2.7kÎ© â‰ˆ 37
        BLUE: 10.0,    // 100kÎ© / 10kÎ© = 10
        YELLOW: 4.55,  // 100kÎ© / 22kÎ© â‰ˆ 4.55
        CYAN: 0.4,     // 100kÎ© / 250kÎ© = 0.4
        PURPLE: 0.1    // 100kÎ© / 1MÎ© = 0.1
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALIBRACIÃ“N PARA 1V/OCTAVA REAL
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // El estÃ¡ndar es: 1V de entrada â†’ 1 octava de cambio
      // 
      // ConversiÃ³n voltaje â†’ digital: cvVoltage / DIGITAL_TO_VOLTAGE
      // Ejemplo: 1V / 4V = 0.25 digital
      //
      // Para que 0.25 digital = 1 octava (1200 cents):
      // centsGain = 1200 / 0.25 = 4800 cents por unidad digital
      //
      // Con pin GREY (ganancia Ã—1):
      // centsGain = VOLTS_PER_OCTAVE Ã— DIGITAL_TO_VOLTAGE Ã— 1200 = 4800
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const pinGain = PIN_GAINS[pinType] || 1.0;
      
      // Ganancia total para el sistema CV del oscilador
      // Esta es la calibraciÃ³n correcta para 1V/Octava
      const centsPerVolt = 1200;  // 1 octava = 1200 cents
      const centsGain = centsPerVolt * DIGITAL_TO_VOLTAGE * pinGain;
      // Con GREY: 1200 Ã— 4 Ã— 1 = 4800 cents por unidad digital
      
      log(`CV Test: ${cvVoltage}V via ${pinType} pin (gain=${pinGain}Ã—) to ${waveform}@${baseFrequency}Hz`);
      log(`  centsGain=${centsGain}, expected shift=${cvVoltage * centsPerVolt} cents`);

      const length = Math.ceil(sampleRate * duration);
      
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR SIN CV (frecuencia base)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineBase = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineBase.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscBase = new AudioWorkletNode(offlineBase, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscBase.parameters.get('frequency').value = baseFrequency;
      oscBase.parameters.get('gain').value = 1.0;
      oscBase.parameters.get('detune').value = 0;  // Sin CV
      oscBase.connect(offlineBase.destination);
      
      const bufferBase = await offlineBase.startRendering();
      const samplesBase = bufferBase.getChannelData(0);
      const spectrumBase = computeSpectrum(samplesBase, sampleRate);
      const dominantBase = findDominantFrequency(spectrumBase);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR CON CV (frecuencia modulada)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offlineCV = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offlineCV.audioWorklet.addModule('/src/assets/js/worklets/synthOscillator.worklet.js');
      
      const oscCV = new AudioWorkletNode(offlineCV, 'synth-oscillator', {
        processorOptions: { mode: 'single', waveform, sineShapeAttenuation: 0, sinePurity: 1.0 },
        numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1]
      });
      oscCV.parameters.get('frequency').value = baseFrequency;
      oscCV.parameters.get('gain').value = 1.0;
      
      // Aplicar CV: convertir voltios â†’ digital â†’ cents
      // 1V â†’ 0.25 digital â†’ 0.25 Ã— 4800 = 1200 cents = 1 octava
      const cvDigital = cvVoltage / DIGITAL_TO_VOLTAGE;  // Voltios a digital
      const cvCents = cvDigital * centsGain;             // Digital a cents
      oscCV.parameters.get('detune').value = cvCents;
      
      log(`  cvDigital=${cvDigital.toFixed(4)}, cvCents=${cvCents.toFixed(1)}`);
      
      oscCV.connect(offlineCV.destination);
      
      const bufferCV = await offlineCV.startRendering();
      const samplesCV = bufferCV.getChannelData(0);
      const spectrumCV = computeSpectrum(samplesCV, sampleRate);
      const dominantCV = findDominantFrequency(spectrumCV);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALCULAR RESULTADOS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const measuredBaseFreq = dominantBase?.frequency || 0;
      const measuredCVFreq = dominantCV?.frequency || 0;
      
      // Calcular ratio de frecuencias (deberÃ­a ser 2 para +1V, 0.5 para -1V)
      const frequencyRatio = measuredCVFreq / measuredBaseFreq;
      
      // Calcular octavas de cambio: log2(ratio)
      const octavesChange = Math.log2(frequencyRatio);
      
      // Frecuencia esperada segÃºn 1V/Oct
      const expectedFreq = baseFrequency * Math.pow(2, cvVoltage / VOLTS_PER_OCTAVE);
      
      log(`  Result: base=${measuredBaseFreq.toFixed(1)}Hz, withCV=${measuredCVFreq.toFixed(1)}Hz`, 'success');
      log(`  Ratio=${frequencyRatio.toFixed(4)}, octaves=${octavesChange.toFixed(4)}, expected=${expectedFreq.toFixed(1)}Hz`);

      return {
        config: { baseFrequency, cvVoltage, waveform, pinType, rangeLow },
        calibration: {
          pinGain,
          centsGain,
          cvDigital,
          cvCents
        },
        baseFrequency: {
          requested: baseFrequency,
          measured: measuredBaseFreq,
          rms: calculateRMS(samplesBase),
          peak: calculatePeak(samplesBase)
        },
        withCV: {
          expected: expectedFreq,
          measured: measuredCVFreq,
          rms: calculateRMS(samplesCV),
          peak: calculatePeak(samplesCV)
        },
        analysis: {
          frequencyRatio,
          octavesChange,
          expectedOctaves: cvVoltage / VOLTS_PER_OCTAVE,
          error: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)),
          errorCents: Math.abs(octavesChange - (cvVoltage / VOLTS_PER_OCTAVE)) * 1200
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST: CV THERMAL SLEW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Testea el efecto de slew tÃ©rmico en seÃ±ales CV.
     * 
     * Emula la inercia tÃ©rmica del transistor en VCOs del Synthi 100:
     * - Calentamiento rÃ¡pido (subida): Ï„ â‰ˆ 150ms
     * - Enfriamiento lento (bajada): Ï„ â‰ˆ 500ms
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.cvStep - Magnitud del salto CV (en unidades digitales)
     * @param {string} config.direction - 'up' o 'down'
     * @param {number} [config.threshold=0.5] - Umbral de activaciÃ³n
     * @param {number} [config.riseTimeConstant=0.15] - Constante de tiempo subida (s)
     * @param {number} [config.fallTimeConstant=0.5] - Constante de tiempo bajada (s)
     * @param {number} [config.duration=1.0] - DuraciÃ³n del test en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} Resultados del anÃ¡lisis de slew
     */
    window.testThermalSlew = async function(config) {
      const {
        cvStep = 2.0,
        direction = 'up',
        threshold = 0.5,
        riseTimeConstant = 0.15,
        fallTimeConstant = 0.5,
        duration = 1.0,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const stepSample = Math.floor(sampleRate * 0.1);  // Salto a los 100ms

      log(`Thermal Slew Test: step=${cvStep}, direction=${direction}, threshold=${threshold}`);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR CONTEXTO Y CARGAR WORKLET
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR FUENTE CV CON SALTO INSTANTÃNEO
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const cvSource = offline.createConstantSource();
      if (direction === 'up') {
        cvSource.offset.setValueAtTime(0, 0);
        cvSource.offset.setValueAtTime(cvStep, stepSample / sampleRate);
      } else {
        cvSource.offset.setValueAtTime(cvStep, 0);
        cvSource.offset.setValueAtTime(0, stepSample / sampleRate);
      }
      cvSource.start();

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR PROCESADOR THERMAL SLEW
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const thermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
        processorOptions: {
          riseTimeConstant,
          fallTimeConstant
        },
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      thermalSlew.parameters.get('threshold').value = threshold;
      thermalSlew.parameters.get('enabled').value = 1;

      // Conectar: source â†’ thermal slew â†’ destination
      cvSource.connect(thermalSlew);
      thermalSlew.connect(offline.destination);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // RENDERIZAR Y ANALIZAR
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Encontrar tiempo de respuesta: tiempo para alcanzar 63% del target
      const startIdx = stepSample;
      const targetValue = direction === 'up' ? cvStep : 0;
      const startValue = direction === 'up' ? 0 : cvStep;
      const deltaNeeded = Math.abs(targetValue - startValue) * 0.632;  // 63.2% (1 - e^-1)
      
      let settlingIdx = length - 1;
      for (let i = startIdx; i < samples.length; i++) {
        const progress = Math.abs(samples[i] - startValue);
        if (progress >= deltaNeeded) {
          settlingIdx = i;
          break;
        }
      }
      const settlingTime = (settlingIdx - startIdx) / sampleRate;

      // Medir valor final
      const finalValue = samples[samples.length - 1];
      
      // Medir si el slew se activÃ³ (valor intermedio entre start y target durante transiciÃ³n)
      const midIdx = startIdx + Math.floor((settlingIdx - startIdx) / 2);
      const midValue = samples[midIdx];
      const midExpected = startValue + (targetValue - startValue) * 0.5;
      const slewActive = Math.abs(midValue - targetValue) > 0.01;

      // Calcular asimetrÃ­a (ratio de tiempos de respuesta)
      // Para esto necesitamos medir ambas direcciones si es posible
      const expectedTimeConstant = direction === 'up' ? riseTimeConstant : fallTimeConstant;

      log(`  Settling time: ${(settlingTime * 1000).toFixed(1)}ms (expected ~${(expectedTimeConstant * 1000).toFixed(0)}ms)`);
      log(`  Final value: ${finalValue.toFixed(4)} (target: ${targetValue})`);

      return {
        config: {
          cvStep,
          direction,
          threshold,
          riseTimeConstant,
          fallTimeConstant
        },
        analysis: {
          settlingTime,
          settlingTimeMs: settlingTime * 1000,
          expectedTimeConstantMs: expectedTimeConstant * 1000,
          timeConstantRatio: settlingTime / expectedTimeConstant,
          slewActive,
          finalValue,
          targetValue,
          finalError: Math.abs(finalValue - targetValue)
        },
        samples: {
          beforeStep: samples[startIdx - 10],
          atStep: samples[startIdx + 1],
          midSlew: midValue,
          final: finalValue
        }
      };
    };

    /**
     * Test de bypass del thermal slew.
     */
    window.testThermalSlewBypass = async function(config) {
      const {
        cvStep = 2.0,
        duration = 0.2,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const stepSample = Math.floor(sampleRate * 0.05);

      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });
      await offline.audioWorklet.addModule('/src/assets/js/worklets/cvThermalSlew.worklet.js');

      const cvSource = offline.createConstantSource();
      cvSource.offset.setValueAtTime(0, 0);
      cvSource.offset.setValueAtTime(cvStep, stepSample / sampleRate);
      cvSource.start();

      const thermalSlew = new AudioWorkletNode(offline, 'cv-thermal-slew', {
        numberOfInputs: 1,
        numberOfOutputs: 1,
        outputChannelCount: [1]
      });
      thermalSlew.parameters.get('enabled').value = 0;  // BYPASS

      cvSource.connect(thermalSlew);
      thermalSlew.connect(offline.destination);

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // En bypass, el salto debe ser instantÃ¡neo
      const valueBeforeStep = samples[stepSample - 1];
      const valueAfterStep = samples[stepSample + 10];

      return {
        bypass: true,
        valueBeforeStep,
        valueAfterStep,
        expectedBeforeStep: 0,
        expectedAfterStep: cvStep,
        instantaneous: Math.abs(valueAfterStep - cvStep) < 0.01
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEST: HYBRID CLIPPING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Genera la curva de clipping hÃ­brido (replica de voltageConstants.js).
     * Tres zonas: lineal â†’ soft (tanh) â†’ hard clip
     */
    function createHybridClipCurve(
      samples = 1024,
      linearThreshold = 2.25,
      softThreshold = 2.875,
      hardLimit = 3.0,
      softness = 2.0
    ) {
      const curve = new Float32Array(samples);
      const softZoneWidth = hardLimit - linearThreshold;
      
      for (let i = 0; i < samples; i++) {
        const t = i / (samples - 1);
        const normalizedIndex = 2 * t - 1;
        const x = normalizedIndex * hardLimit;
        
        const absX = Math.abs(x);
        const sign = x >= 0 ? 1 : -1;
        
        let y;
        
        if (absX <= linearThreshold) {
          y = x;
        } else if (absX < hardLimit) {
          const excess = absX - linearThreshold;
          const normalizedExcess = excess / softZoneWidth;
          const compressedNormalized = Math.tanh(softness * normalizedExcess);
          let compressedExcess = compressedNormalized * softZoneWidth;
          compressedExcess = Math.min(compressedExcess, excess);
          
          const interpFrac = 0.05;
          if (normalizedExcess < interpFrac) {
            const alpha = normalizedExcess / interpFrac;
            const ySoft = linearThreshold + compressedExcess;
            const yLinear = absX;
            y = sign * (yLinear * (1 - alpha) + ySoft * alpha);
          } else {
            y = sign * (linearThreshold + compressedExcess);
          }
        } else {
          y = sign * hardLimit;
        }
        
        curve[i] = y;
      }
      
      return curve;
    }

    /**
     * Testea el comportamiento del clipping hÃ­brido con seÃ±ales de audio.
     * 
     * Verifica las tres zonas de la curva de saturaciÃ³n:
     * - Zona lineal: |V| < 9V (2.25 digital) â†’ THD muy bajo
     * - Zona soft: 9V < |V| < 11.5V â†’ THD moderado (tanh suave)
     * - Zona hard: |V| > 12V (3.0 digital) â†’ THD alto (clipping duro)
     * 
     * NOTA: El WaveShaperNode opera en rango [-1, +1], asÃ­ que normalizamos
     * la entrada dividiÃ©ndola por hardLimit y luego multiplicamos la salida.
     * 
     * @param {Object} config - ConfiguraciÃ³n del test
     * @param {number} config.amplitude - Amplitud de entrada (en unidades digitales)
     * @param {number} [config.frequency=440] - Frecuencia del tono de prueba
     * @param {number} [config.linearThreshold=2.25] - Umbral zona lineal
     * @param {number} [config.softThreshold=2.875] - Umbral zona soft
     * @param {number} [config.hardLimit=3.0] - LÃ­mite duro (raÃ­les Â±12V)
     * @param {number} [config.duration=0.5] - DuraciÃ³n en segundos
     * @param {number} [config.sampleRate=44100] - Sample rate
     * @returns {Object} AnÃ¡lisis de THD y forma de onda
     */
    window.testHybridClipping = async function(config) {
      const {
        amplitude = 1.0,
        frequency = 440,
        linearThreshold = 2.25,
        softThreshold = 2.875,
        hardLimit = 3.0,
        softness = 2.0,
        duration = 0.5,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);

      log(`Hybrid Clip Test: amplitude=${amplitude}, freq=${frequency}Hz`);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CREAR CONTEXTO Y WAVESHAPER
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Crear oscilador limpio
      const osc = offline.createOscillator();
      osc.frequency.value = frequency;
      osc.type = 'sine';

      // El WaveShaperNode opera en [-1, +1]
      // Nuestra curva estÃ¡ definida para entrada/salida en [-hardLimit, +hardLimit]
      // AsÃ­ que normalizamos: entrada_ws = entrada_real / hardLimit
      //                       salida_real = salida_ws * hardLimit
      
      // Pre-gain: escala la amplitud al rango de entrada del WaveShaper
      // Si amplitude=3.0 y hardLimit=3.0, preGain=1.0 (entrada llega a Â±1)
      // Si amplitude=1.0 y hardLimit=3.0, preGain=0.333 (entrada llega a Â±0.333)
      const preGain = offline.createGain();
      preGain.gain.value = amplitude / hardLimit;

      // Crear WaveShaper con curva hÃ­brida
      // La curva mapea [-1,+1] â†’ curva normalizada
      const shaper = offline.createWaveShaper();
      shaper.curve = createHybridClipCurve(1024, linearThreshold, softThreshold, hardLimit, softness);
      shaper.oversample = '2x';

      // Post-gain: NO lo aplicamos para la mediciÃ³n
      // Queremos medir el output del shaper directamente para comparar con hardLimit
      
      // Conectar cadena directa (sin post-gain para mediciÃ³n correcta)
      osc.connect(preGain);
      preGain.connect(shaper);
      shaper.connect(offline.destination);
      osc.start();

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ANÃLISIS: THD y caracterÃ­sticas
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const spectrum = computeSpectrum(samples, sampleRate);
      const dominant = findDominantFrequency(spectrum);
      const thd = measureTHD(spectrum, frequency, 10);

      // Medir pico de salida (del WaveShaper, ya en escala hardLimit)
      const outputPeak = calculatePeak(samples);
      const inputPeak = amplitude;

      // Determinar zona de operaciÃ³n basada en la amplitud de entrada
      let zone;
      if (amplitude <= linearThreshold) {
        zone = 'linear';
      } else if (amplitude <= hardLimit) {
        zone = 'soft';
      } else {
        zone = 'hard';
      }

      // Calcular compresiÃ³n (ratio entrada/salida en pico)
      const compressionRatio = outputPeak > 0 ? inputPeak / outputPeak : 1;
      
      // Determinar si estÃ¡ clippeando (output cerca del hardLimit)
      const isClipping = outputPeak >= hardLimit * 0.95;

      log(`  Zone: ${zone}, THD: ${thd?.toFixed(2)}%, Peak out: ${outputPeak.toFixed(3)}`);

      return {
        config: {
          amplitude,
          frequency,
          linearThreshold,
          softThreshold,
          hardLimit,
          softness
        },
        analysis: {
          zone,
          thd,
          thdPercent: thd,
          dominantFrequency: dominant?.frequency || 0,
          inputPeak,
          outputPeak,
          compressionRatio,
          isCompressing: compressionRatio > 1.05,
          isClipping
        }
      };
    };

    /**
     * Test de simetrÃ­a del clipping hÃ­brido.
     * Verifica que la distorsiÃ³n es igual para seÃ±ales positivas y negativas.
     */
    window.testHybridClipSymmetry = async function(config) {
      const {
        amplitude = 2.5,
        hardLimit = 3.0,
        duration = 0.1,
        sampleRate = 44100
      } = config;

      const length = Math.ceil(sampleRate * duration);
      const offline = new OfflineAudioContext({ numberOfChannels: 1, length, sampleRate });

      // Crear rampa lineal de -1 a +1 (normalizada)
      const bufferSource = offline.createBufferSource();
      const rampBuffer = offline.createBuffer(1, length, sampleRate);
      const rampData = rampBuffer.getChannelData(0);
      
      // La rampa va de -amplitude/hardLimit a +amplitude/hardLimit
      // para que la entrada al WaveShaper estÃ© correctamente escalada
      const normalizedAmplitude = amplitude / hardLimit;
      for (let i = 0; i < length; i++) {
        rampData[i] = ((i / (length - 1)) * 2 - 1) * normalizedAmplitude;
      }
      bufferSource.buffer = rampBuffer;

      const shaper = offline.createWaveShaper();
      shaper.curve = createHybridClipCurve(1024);
      shaper.oversample = '2x';

      // Conectar directamente (sin gains)
      bufferSource.connect(shaper);
      shaper.connect(offline.destination);
      bufferSource.start();

      const buffer = await offline.startRendering();
      const samples = buffer.getChannelData(0);

      // Comparar valores positivos vs negativos (deberÃ­an ser simÃ©tricos)
      const midIdx = Math.floor(length / 2);
      let maxAsymmetry = 0;
      for (let i = 0; i < midIdx; i++) {
        const negVal = samples[i];
        const posVal = samples[length - 1 - i];
        const asymmetry = Math.abs(Math.abs(negVal) - Math.abs(posVal));
        if (asymmetry > maxAsymmetry) maxAsymmetry = asymmetry;
      }

      return {
        amplitude,
        maxAsymmetry,
        isSymmetric: maxAsymmetry < 0.05,  // Tolerancia mÃ¡s amplia
        samples: {
          negPeak: Math.min(...samples),
          posPeak: Math.max(...samples)
        }
      };
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INICIALIZACIÃ“N
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async function init() {
      try {
        log('Verificando soporte Web Audio...');
        
        if (!window.AudioContext && !window.webkitAudioContext) {
          throw new Error('Web Audio API no soportada');
        }
        
        if (!window.OfflineAudioContext) {
          throw new Error('OfflineAudioContext no soportado');
        }
        
        // Test rÃ¡pido de AudioWorklet
        const testCtx = new OfflineAudioContext(1, 1024, 44100);
        if (!testCtx.audioWorklet) {
          throw new Error('AudioWorklet no soportado');
        }
        
        log('Web Audio API disponible', 'success');
        log('OfflineAudioContext disponible', 'success');
        log('AudioWorklet disponible', 'success');
        
        setStatus('âœ… Harness listo para tests de audio', 'ready');
        
        // Marcar como listo para Playwright
        window.__AUDIO_HARNESS_READY__ = true;
        
      } catch (error) {
        log(`Error: ${error.message}`, 'error');
        setStatus(`âŒ Error: ${error.message}`, 'error');
        window.__AUDIO_HARNESS_READY__ = false;
      }
    }

    init();
  </script>
</body>
</html>
